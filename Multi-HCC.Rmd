---
title: "Multi-HCC"
output:
  html_document: default
date: "2024-08-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)

library(tidyverse)
library(haven)
library(survminer)
library(gridExtra)
library(compareC)
library(tableone)

library(survival)
library(randomForestSRC)
library(gbm)
library(survivalmodels)
library(pec)
library(mgcv)

library(foreach)
library(doParallel)

# Cluster object
cl = parallel::makeCluster(parallel::detectCores() - 2)
# Register parallel backend
registerDoParallel(cl)

# Force rfsrc to use 1 core/no parallelization
# Keeps things from exploding during parallelized bootstrap
# Doesn't seem to be working anymore
options(mc.cores = 1, rf.cores = 1)

# Set background to be white for all ggplots
theme_set(theme_classic())
```

## Data processing

First, we read in the data. 

```{r}
# Data directory
dir = "/Users/jliang/Library/CloudStorage/Box-Box/HCC\ modeling/Data/"

# Read in data
liverdata = read_sas(paste0(dir, "liver_data.sas7bdat"))
exceptiondata = read_sas(paste0(dir, "liver_exception_data.sas7bdat"))
wlhxdata = read_sas(paste0(dir, "liver_wlhistory_data.sas7bdat"))
```

The cohort is defined as adult patients with initial exception between October 8, 2015 and December 31, 2022. Non-HCC patients are those who are not in the exception list.

```{r}
cohort = liverdata %>% 
  dplyr::select(-HCC_DIAG) %>% 
  # Join initial exception date
  left_join(
    exceptiondata %>% 
      group_by(WL_ID_CODE) %>% 
      arrange(BEGIN_DATE) %>% 
      dplyr::slice(1) %>%
      ungroup() %>% 
      dplyr::select(WL_ID_CODE, BEGIN_DATE, HCC_DIAG, CASE_OUTCOME), 
    by = "WL_ID_CODE") %>% 
  filter(
    # Adults
    INIT_AGE >= 18, 
    # Has HCC
    # Has HCC diagnosis and this is the first approved HCC exception
    # (Hepatoma – Hepatocellular Carcinoma) or 4401 (Hepatoma (HCC) and Cirrhosis
    ((HCC_DIAG != "" & CASE_OUTCOME == "Request Approved" ) & 
       # with initial exception between October 8, 2015 and December 31, 2022
       BEGIN_DATE >= as.Date("2015-10-8") & BEGIN_DATE <= as.Date("2022-12-31")) |
      # Or is non-HCC (not in exception list)
      (!(WL_ID_CODE %in% exceptiondata$WL_ID_CODE) & 
         # Exclude previous transplants 
         (PREV_TX != "Y" & (NUM_PREV_TX < 1 | is.na(NUM_PREV_TX))) & 
         # Exclude multiorgan other than liver kidney
         (WLHL != "Y "& WLHL != "Y" & WLLU != "Y" & WLIN != "Y") & 
         # With initial date between October 8, 2015 and December 31, 2022
         (INIT_DATE >= as.Date("2015-10-08") & INIT_DATE <= as.Date("2022-12-31")))) %>% 
  mutate(HCC = replace_na(
    ifelse(HCC_DIAG != "" & CASE_OUTCOME == "Request Approved", 1, 0), 0))
```

Using the exception and waitlist history data, we extract the MELD 3.0 components, AFP and tumor type for HCC patients are taken as close to the initial exception date as possible. MELD 3.0 components must be with 90 days of initial exception. 

```{r}
# Liver exception data
exception = exceptiondata %>% 
  filter(WL_ID_CODE %in% cohort$WL_ID_CODE & # Restrict to cohort
           !is.na(BEGIN_DATE)) %>% # Non-missing start date for exception
  right_join(cohort %>% dplyr::select(WL_ID_CODE, INIT_DATE), 
             by="WL_ID_CODE") %>% # Merge in initial listing date
  group_by(WL_ID_CODE) %>% 
  arrange(BEGIN_DATE) %>% 
  # Has HCC diagnosis and this is the first approved HCC exception
  filter(HCC_DIAG != "" & CASE_OUTCOME == "Request Approved") %>%      
  # Time since listing
  mutate(wltime = as.numeric(BEGIN_DATE - INIT_DATE)) %>% 
  # Keep observation closest to listing time
  dplyr::slice(1) %>% 
  # Replace NA with 0 
  mutate_at(vars(c("ORIG_TUMOR_SIZE1", "ORIG_TUMOR_SIZE2", "ORIG_TUMOR_SIZE3",
                   "ORIG_TUMOR_SIZE4", "ORIG_TUMOR_SIZE5", "TUMOR_SIZE1", 
                   "TUMOR_SIZE2", "TUMOR_SIZE3", "TUMOR_SIZE4", "TUMOR_SIZE5")), 
            ~ifelse(is.na(.), 0, .)) %>%
  mutate(
    # Find the largest tumor size
    largesttumor = pmax(TUMOR_SIZE2, TUMOR_SIZE1, TUMOR_SIZE3, TUMOR_SIZE4, TUMOR_SIZE5), 
    # Sum of all tumor sizes
    TTS = TUMOR_SIZE1 + TUMOR_SIZE2 + TUMOR_SIZE3 + TUMOR_SIZE4 + TUMOR_SIZE5, 
    # Define outsideMilan based on number of tumors + tumor size
    outsideMilan = replace_na(
      ifelse((TUMORNUM == 1 & TUMOR_SIZE1 > 5) | 
               (TUMORNUM >= 2 & (TUMOR_SIZE1 > 3 | TUMOR_SIZE2 > 3 | TUMOR_SIZE3 > 3)) | 
               TUMORNUM > 3, 1, 0), 0), 
    # Define some more variables based on tumor info
    solitaryHCC = ifelse(TUMORNUM == 1 & TUMOR_SIZE1 <= 3, 1 ,0), 
    # Total number of tumors
    total_tumor_num = (ORIG_TUMOR_SIZE1 > 1) + (ORIG_TUMOR_SIZE2 > 1) + 
      (ORIG_TUMOR_SIZE3 > 1) + (ORIG_TUMOR_SIZE4 > 1) + (ORIG_TUMOR_SIZE5 > 1), 
    # T1: none or < 2 cm of tumor (presumably already treated)
    T1 = (TUMORNUM == 0) | ( TUMORNUM == 1 & TUMOR_SIZE1 < 2), 
    T1_dx = (total_tumor_num == 0) | ( total_tumor_num == 1 & ORIG_TUMOR_SIZE1 < 2), 
    # T2: single solitary tumor 2-3 cm
    single_tumor_2_3 = TUMORNUM == 1 & TUMOR_SIZE1 >= 2 & TUMOR_SIZE1 <= 3, 
    T2_dx_2_3 = total_tumor_num == 1 & ORIG_TUMOR_SIZE1 >= 2 & ORIG_TUMOR_SIZE1 <= 3, 
    # T2: single large tumor >3 cm and ≤5 cm
    single_tumor_3_5 = TUMORNUM == 1 & TUMOR_SIZE1 > 3 & TUMOR_SIZE1 <= 5, 
    T2_dx_3_5 = total_tumor_num == 1 & ORIG_TUMOR_SIZE1 > 3 & ORIG_TUMOR_SIZE1 <= 5, 
    # T2: multifocal
    T2_multifocal = 
      (total_tumor_num == 2  & ORIG_TUMOR_SIZE1 >= 1 & ORIG_TUMOR_SIZE1 <= 3 & 
         ORIG_TUMOR_SIZE2 >= 2 & ORIG_TUMOR_SIZE2 <= 3) | 
      (total_tumor_num == 3 & ORIG_TUMOR_SIZE1 >= 1 & ORIG_TUMOR_SIZE1 <= 3 & 
         ORIG_TUMOR_SIZE2 >= 1 & ORIG_TUMOR_SIZE2 <= 3 & 
         ORIG_TUMOR_SIZE3 >= 1 & ORIG_TUMOR_SIZE3 <= 3),
    # T3: single tumor > 5 cm or >3 tumors
    T3 = replace_na(
      ifelse((TUMORNUM == 1 & TUMOR_SIZE1 > 5) | 
               (TUMORNUM >= 2 & (TUMOR_SIZE1 > 3 | TUMOR_SIZE2 > 3 | TUMOR_SIZE3 > 3)) | 
               TUMORNUM > 3, 1, 0), 0), 
    multifocal_2_3 = TUMORNUM %in% c(2, 3) & T3 == 0, 
    T3_dx = !T1_dx & !T2_dx_2_3 & !T2_dx_3_5 & !T2_multifocal, 
    # Tumor type
    tumortype = case_when( 
      T1 == TRUE | single_tumor_2_3 == TRUE ~ "T1, T2 2-3", 
      single_tumor_3_5 == TRUE ~ "T2 3-5", 
      multifocal_2_3 == TRUE ~ "multifocal", 
      T3 == 1 ~ "T3"), 
    tumortype=ifelse(T1==TRUE & T3_dx==TRUE,"T3",tumortype), 
    tumortype=ifelse(T1==TRUE & T2_dx_2_3==TRUE,"T1, T2 2-3",tumortype), 
    tumortype=ifelse(T1==TRUE & T2_dx_3_5==TRUE,"T2 3-5",tumortype), 
    tumortype=ifelse(T1==TRUE & T2_multifocal==TRUE,"multifocal",tumortype), 
    # AFP categories
    AFPcat = case_when(
      AFP <= 20 ~ "<=20", 
      AFP > 20 & AFP <= 40 ~ "21-40", 
      AFP > 40 & AFP <= 400 ~ "41-400", 
      AFP > 400 ~ "401+"), 
    # Previous treatment
    historyLRT = replace_na(ifelse(
      first(TREAT_DATE1) < BEGIN_DATE | 
        first(TREAT_DATE2) < BEGIN_DATE | 
        first(TREAT_DATE3) < BEGIN_DATE, 
      1 , 0), 0), 
    ) %>% 
  ungroup()

# Liver waitlist history data
wlhx = wlhxdata %>% 
  filter(WL_ID_CODE %in% cohort$WL_ID_CODE) %>% # Subset cohort
  right_join(cohort %>% dplyr::select(WL_ID_CODE, BEGIN_DATE), 
             by="WL_ID_CODE") %>% # Merge in initial exception date
  group_by(WL_ID_CODE) %>% 
  arrange(CHG_DATE) %>% # Order by waitlist modification date
  # Days between waitlist modification and initial exception
  mutate(wltime = as.numeric(CHG_DATE - BEGIN_DATE)) %>% 
  # Filter out observations that are more than +/- 90 day of initial exception
  filter(wltime > -90, wltime < 90) %>% 
  # Keep observation closest to listing time
  dplyr::slice(which.min(abs(wltime))) %>% 
  ungroup()
```

Join all data together and define outcome for time to waitlist removal or death within 6 months, censored at time of transplant or administrative censoring at 6 months. Non-HCC patients will not have AFP or tumor variables (only dummy values filled in), but these variables wil only contribute to the HCC predictions.

```{r}
# Calculate MELD
calc_meld = function(bilirubin, inr, creat) {
  9.57 * log(creat) + 3.78 * log(bilirubin) + 11.20 * log(inr) + 6.43
}

# Calculate MELD-Na
calc_meldna = function(meld, na) {
  round(meld + 1.32 * (137 - na) - (0.033 * meld * (137 - na)))
}

# Calculate MELD 3.0 (Kim et al., 2021)
calc_meld3 = function(female, bilirubin, na, inr, creat, alb) {
  round(1.33 * female + 4.56 * log(bilirubin) + 0.82 * (137 - na) - 
          0.24 * (137 - na) * log(bilirubin) + 9.09 * log(inr) + 
          11.14 * log(creat) + 1.85 * (3.5 - alb) - 
          1.83 * (3.5 - alb) * log(creat) + 6)
}

# Child-Pugh score
# ascites: 1 = Absent, 2 = Slight, 3 = Moderate, 4 = N/A
# enceph: 1 = None, 2 = 1-2, 3 = 3-4, 4 = N/A
calc_child_pugh = function(bilirubin, inr, alb, ascites, enceph) {
  ((bilirubin < 2) + (alb > 3.5) + (inr < 1.7) + (ascites == 1 | ascites == 4) + 
     (enceph == 1 | enceph == 4)) + 
    2 * ((bilirubin >= 2 & bilirubin <= 3) + (alb >= 2.8 & alb <= 3.5) + 
           (inr >= 1.7 & inr <= 2.3) + (ascites == 2) + (enceph == 2)) +
    3 * ((bilirubin > 3) + (alb < 2.8) + (inr > 2.3) + (ascites == 3) + (enceph == 3))
}

# Neil Mehta's score
calc_mehta = function(meld_na, child_pugh, afp, tumor_num, tumor_size1) {
  (meld_na - 10) + ((child_pugh - 5) * 3) + 5 * (afp > 21 & afp <= 40) + 
    9 * (afp > 40 & afp <= 500) + 20 * (afp > 500 & afp <= 1000) + 
    23 * (afp > 1000) + 6 * (tumor_num == 1 & tumor_size1 >= 3.1 & tumor_size1 <= 5) + 
    5 * (tumor_num >= 2 & tumor_num <= 3)
}

# HALT-HCC
# size, defined by the Pythagorean theorem
calc_halt_hcc = function(meldna, afp, tbs) {
  (1.27 * tbs) + (1.85 * log(afp)) + (0.26 * meldna)
}

# deMELD
# Cause of liver disease?
calc_demeld = function(age, meld, afp, tumor_num, tumor_size, 
                       hepb, alcohol, nash, hemochrom) {
  -25 + (0.1 * age) + (1.6 * meld) + (1.6 * tumor_size) + 
    (1.3 - log(afp)) + 6 * (tumor_num > 2) - 
    (hepb == 1) + 3 * (alcohol == 1) + 3 * (nash == 1) + 
    (hemochrom == 1)
}

# HCC-MELD
calc_hcc_meld = function(meld, afp) {
  1.27 * meld - 0.51 * log(afp) + 4.59
}

# MELD-Eq
calc_meld_eq = function(meld, afp, tumor_num, tumor_size_max, wl_drop_months) {
  pmax(meld, 1.143 * meld + 1.324 * log(afp) + 1.438 * tumor_num + 
         1.194 * tumor_size_max - 2/0.146 * (wl_drop_months < 6) - 
         1/0.146 * (wl_drop_months >= 6))
}

df = cohort %>% 
    dplyr::select(WL_ID_CODE, INIT_DATE, REM_CD, END_DATE, TX_DATE,
                  PX_STAT_DATE, PX_STAT, INIT_AGE, GENDER, DAYSWAIT_CHRON, 
                  DGN_TCR, DGN2_TCR, HCC_EVER_APPR, EVER_APPROVED, 
                  CASE_OUTCOME, HCC, INIT_DIALYSIS_PRIOR_WEEK, INIT_BILIRUBIN, 
                  INIT_INR, INIT_ALBUMIN, INIT_SERUM_CREAT, INIT_SERUM_SODIUM, 
                  INIT_ASCITES, INIT_ENCEPH) %>% 
  left_join(
    exception %>% 
      dplyr::select(-(CONTRAST1:WASHOUT8), -(TREAT1:ULTSND_DATE5), -(TACE:ABLATE), -INIT_DATE), 
    by = "WL_ID_CODE") %>% 
  left_join(
    wlhx %>% dplyr::select(WL_ID_CODE, BILIRUBIN, INR, ALBUMIN, SERUM_CREAT, 
                           SERUM_SODIUM, ASCITES, ENCEPH, CHG_DATE, 
                           DIALYSIS_PRIOR_WEEK, wltime, MELD_PELD_LAB_SCORE), 
    by = "WL_ID_CODE"
  ) %>% 
  mutate(
    # Set AFP and tumor variables to 0 for non-HCC patients 
    # (these are all just decoys)
    AFP = ifelse(HCC == TRUE, AFP, 0), 
    AFPcat = ifelse(HCC == TRUE, AFPcat, "<=20"), 
    tumortype = factor(ifelse(HCC == TRUE, tumortype, "T1, T2 2-3"), 
                       levels = c("T1, T2 2-3", "T2 3-5", "multifocal", "T3")), 
    historyLRT = ifelse(HCC == TRUE, historyLRT, 0), 
    # Female
    FEMALE = GENDER == "F", 
    # Coalesce lab values for non-HCC (from liver file, prefixed INIT) with 
    # lab values for HCC (from waitlist file, closest to date)
    BILIRUBIN = coalesce(BILIRUBIN, INIT_BILIRUBIN), 
    INR = coalesce(INR, INIT_INR), 
    ALBUMIN = coalesce(ALBUMIN, INIT_ALBUMIN), 
    SERUM_CREAT = coalesce(SERUM_CREAT, INIT_SERUM_CREAT), 
    SERUM_SODIUM = coalesce(SERUM_SODIUM, INIT_SERUM_SODIUM), 
    DIALYSIS_PRIOR_WEEK = coalesce(DIALYSIS_PRIOR_WEEK, INIT_DIALYSIS_PRIOR_WEEK), 
    ASCITES = coalesce(ASCITES, INIT_ASCITES), 
    ENCEPH = coalesce(ENCEPH, INIT_ENCEPH), 
    BEGIN_INIT_DATE = coalesce(BEGIN_DATE, INIT_DATE), 
    # Set lower/upper bounds for MELD variables
    MELD_BILIRUBIN = ifelse(BILIRUBIN < 1, 1, BILIRUBIN), 
    MELD_SERUM_SODIUM = ifelse(SERUM_SODIUM > 137, 137, 
                               ifelse(SERUM_SODIUM < 125, 125, SERUM_SODIUM)), 
    MELD_INR = ifelse(INR < 1, 1, INR), 
    MELD_SERUM_CREAT_1 = ifelse(SERUM_CREAT > 4 | DIALYSIS_PRIOR_WEEK == "Y", 4, 
                              ifelse(SERUM_CREAT < 1, 1, SERUM_CREAT)), 
    MELD_SERUM_CREAT = ifelse(SERUM_CREAT > 3 | DIALYSIS_PRIOR_WEEK == "Y", 3, 
                              ifelse(SERUM_CREAT < 1, 1, SERUM_CREAT)), 
    MELD_ALBUMIN = ifelse(ALBUMIN > 3.5, 3.5, ifelse(ALBUMIN < 1.5, 1.5, ALBUMIN)), 
    # Define variables for cause of liver disease
    hepc = DGN_TCR == 4593, # Hepatitis C
    hepb = DGN_TCR == 4592, # Hepatitis B
    alcohol = DGN_TCR %in% c(4215, 4216, 4217), # Alcohol-related
    nash = DGN_TCR == 4214, # NASH
    hemochrom = DGN_TCR == 4302, # Hemochromatosis and others
    # TBS = Tumor Burden Score: the hypotenuse between lesion number and lesion 
    TBS = sqrt(TUMORNUM^2 + largesttumor^2), 
    # MELD 
    MELD = calc_meld(MELD_BILIRUBIN, MELD_INR, MELD_SERUM_CREAT_1), 
    # MELD-NA
    MELDNA = calc_meldna(MELD, MELD_SERUM_SODIUM), 
    # MELD 3.0
    MELD3 = calc_meld3(FEMALE, MELD_BILIRUBIN, MELD_SERUM_SODIUM, 
                       MELD_INR, MELD_SERUM_CREAT, MELD_ALBUMIN), 
    # Child-Pugh score
    Child_Pugh = calc_child_pugh(BILIRUBIN, INR, ALBUMIN, ASCITES, ENCEPH), 
    # Mehta score
    Mehta = calc_mehta(MELDNA, Child_Pugh, AFP, TUMORNUM, TUMOR_SIZE1), 
    # HALT-HCC
    HALT_HCC = calc_halt_hcc(MELDNA, AFP, TBS), 
    # deMELD
    deMELD = calc_demeld(INIT_AGE, MELD, AFP, TUMORNUM, largesttumor,
                         hepb, alcohol, nash, hemochrom),
    # HCC-MELD
    HCC_MELD = calc_hcc_meld(MELD, AFP), 
    # MELD-Eq
    MELD_Eq = calc_meld_eq(MELD, AFP, TUMORNUM, largesttumor, wltime.y/30), 
    # REM_CD = reason for removal from the waiting list
    # 8 is death, 13 is dropout and 4/15/21 are transplanted
    removed_status = ifelse(REM_CD %in% c(8, 13), 1, 0), # Dead or dropped out
    transplanted_status = ifelse(REM_CD %in% c(4, 15, 21), 1, 0), 
    # INIT_DATE (part of exception data) = start date of listing
    # END_DATE = earliest of dates of removal from waiting list, transplant, 
    # death, or time copy of data created
    fu_days = as.numeric(END_DATE - INIT_DATE), 
    # 90 days
    censored_90days = fu_days > 90, 
    removed_status_90days = ifelse(censored_90days == TRUE, 0, removed_status), 
    fu_days_90days = ifelse(censored_90days == TRUE, 90, fu_days), 
    # 6 months
    censored_6months = fu_days > 180, 
    removed_status_6months = ifelse(censored_6months == TRUE, 0, removed_status), 
    fu_days_6months = ifelse(censored_6months == TRUE, 180, fu_days), 
    # 1 year
    censored_1year = fu_days > 365, 
    removed_status_1year = ifelse(censored_1year == TRUE, 0, removed_status), 
    fu_days_1year = ifelse(censored_1year == TRUE, 365, fu_days)) %>% 
  drop_na(MELD3, AFP, tumortype)
```

### P-splines for log(AFP + 1)

We fit a GAM model to the 6-month outcome with spline terms for log(AFP + 1). 

```{r}
gam_fit = gam(fu_days_6months ~ MELD3 + s(log(AFP + 1)) + tumortype, 
              data = df, family = "cox.ph", weights = removed_status_6months)

plot(gam_fit, ylab = "Hazard Ratio", xlab = "AFP (ng/mL)", 
     xaxt = 'n', xlim = c(0.67, 10))
brks = c(5, 20, 100, 250, 500, 1000, 2500, 5000, 10000)
axis(side = 1, at = log(brks + 1), labels = brks) 
abline(v = c(0, 5.5))
```

Based on the spline exercise, we will bound AFP in our models by 1 and 250 Note that log(250 + 1) is 5.5, so it corresponds approximately to the cutoff of 6 in the above plot. 

```{r}
df = df %>% 
  mutate(AFP_trunc = ifelse(AFP > 250, 250, ifelse(AFP < 1, 1, AFP)))
```

### Train/test split

We split the data into 70% training and 30% test. 

```{r}
# Train-test split
set.seed(1)
idx = sample(nrow(df), 0.7*nrow(df))
train_df = df[idx,]
test_df = df[!(1:nrow(df) %in% idx),]

# Subset HCC cohort only
HCC_train_df = train_df %>% filter(HCC == TRUE)
HCC_test_df = test_df %>% filter(HCC == TRUE)

# Table summarizing counts
rbind(Overall = c(Total = nrow(df), 
                  Train = nrow(train_df), 
                  Test = nrow(test_df)), 
      HCC = c(Total = sum(df$HCC == TRUE), 
              Train = sum(train_df$HCC == TRUE), 
              Test = sum(test_df$HCC == TRUE)), 
      "Non-HCC" = c(Total = sum(df$HCC == FALSE), 
                    Train = sum(train_df$HCC == FALSE), 
                    Test = sum(test_df$HCC == FALSE)))
```

## Fit models to HCC patients

### Cox PH models

We train a Cox PH model to the 6-month outcome and 1) MELD 3.0 only; 2) the individual MELD components; and 3) MELD 3.0, log(AFP) (AFP restricted to be between 1 and 250), and tumor type. 

```{r}
# Model specifications to consider
model_specs = 
  c("MELD 3.0" = "MELD3",
    "MELD 3.0 components" = "FEMALE + log(MELD_BILIRUBIN) + MELD_SERUM_SODIUM + log(MELD_INR) + log(MELD_SERUM_CREAT) + MELD_ALBUMIN", 
    "MELD 3.0 + log(AFP) + tumor burden (Multi-HCC)" = "MELD3 + log(AFP_trunc) + tumortype")

# Cox PH models
fit_coxph_6months = lapply(model_specs, function(mod_form) {
  coxph(as.formula(paste("Surv(fu_days_6months, removed_status_6months) ~", mod_form)), 
        data = HCC_train_df, x = TRUE)
})
pred_coxph_6months = sapply(fit_coxph_6months, predict, newdata = HCC_test_df)
```

### Machine learning models

Fit random survival forest, gradient boosting, and two neural networks (DeepHit and DeepSurv) to the HCC patients. All MELD components, log(AFP), and tumor type are included as features. 

```{r, echo = FALSE}
load("rf.rData")
```

```{r}
# Random survival forest
# Categorical variables must be factors (defined in the data frame, not the 
# formula), not characters
# Factors are also very costly (?), causing R session to abort, so binary 
# variables should be coded as logical/numeric 0/1 when possible
HCC_train_df = 
  data.frame(HCC_train_df, 
             model.matrix(~., HCC_train_df[, "tumortype", drop = FALSE])[,-1])
HCC_test_df = 
  data.frame(HCC_test_df, 
             model.matrix(~., HCC_test_df[, "tumortype", drop = FALSE])[,-1])
```

```{r, eval = FALSE}
# 6 months
fit_rf_6months = rfsrc(
  Surv(fu_days_6months, removed_status_6months) ~ 
    FEMALE + log(MELD_BILIRUBIN) + BILIRUBIN + MELD_SERUM_SODIUM + SERUM_SODIUM + 
    log(MELD_INR) + INR + log(MELD_SERUM_CREAT) + SERUM_CREAT + 
    MELD_ALBUMIN + ALBUMIN + AFP + log(AFP_trunc) + 
    tumortypeT2.3.5 + tumortypemultifocal + tumortypeT3, 
  data = HCC_train_df)
pred_rf_6months = predict(fit_rf_6months, newdata = HCC_test_df)
vimp_rf_6months = vimp(fit_rf_6months, newdata = HCC_test_df)

save(fit_rf_6months, pred_rf_6months, vimp_rf_6months,
     file = "rf.rData")
```

```{r}
# Gradient boosting model
fit_gbm_6months = gbm(
  Surv(fu_days_6months, removed_status_6months) ~ 
    FEMALE + log(MELD_BILIRUBIN) + BILIRUBIN + MELD_SERUM_SODIUM + SERUM_SODIUM + 
    log(MELD_INR) + INR + log(MELD_SERUM_CREAT) + SERUM_CREAT + 
    MELD_ALBUMIN + ALBUMIN + AFP + log(AFP_trunc) + tumortype, 
  data = HCC_train_df %>% 
        mutate(FEMALE = as.factor(FEMALE), 
               tumortype = as.factor(tumortype)), 
      distribution = "coxph")
pred_gbm_6months = predict(fit_gbm_6months, newdata = HCC_test_df %>% 
                            mutate(FEMALE = as.factor(FEMALE), 
                                   tumortype = as.factor(tumortype)))
```

```{r}
# Deep learning
# pycox models to try
pycox_mods = c(
  # Based on the PMF of a discrete Cox model
  "deephit" = deephit, 
  # Based on the partial likelihood from a Cox PH
  "deepsurv" = deepsurv)

# Fit all pycox models with default parameters
set_seed(1)
fit_pycox_6months = lapply(pycox_mods, function(fun) {
  fun(Surv(fu_days_6months, removed_status_6months) ~ ., 
      data = HCC_train_df %>% 
        mutate(
          FEMALE = as.factor(FEMALE), 
          log_MELD_BILIRUBIN = log(MELD_BILIRUBIN), 
          log_MELD_INR = log(MELD_INR), 
          log_MELD_SERUM_CREAT = log(MELD_SERUM_CREAT), 
          log_AFP_trunc = log(AFP_trunc), 
          tumortype = as.factor(tumortype), 
        )  %>% 
        dplyr::select(fu_days_6months, removed_status_6months, FEMALE, 
                      log_MELD_BILIRUBIN, BILIRUBIN, 
                      MELD_SERUM_SODIUM, SERUM_SODIUM, 
                      log_MELD_INR, INR, 
                      log_MELD_SERUM_CREAT, SERUM_CREAT, 
                      MELD_ALBUMIN, ALBUMIN,  
                      log_AFP_trunc, AFP, tumortype))
})
# Predict on data sets
preds_pycox_6months = sapply(fit_pycox_6months, function(fit) {
  predict(fit, 
          newdata = HCC_test_df %>% 
            mutate(
              FEMALE = as.factor(FEMALE), 
              log_MELD_BILIRUBIN = log(MELD_BILIRUBIN), 
              log_MELD_INR = log(MELD_INR), 
              log_MELD_SERUM_CREAT = log(MELD_SERUM_CREAT), 
              log_AFP_trunc = log(AFP_trunc), 
              tumortype = as.factor(tumortype), 
            )  %>% 
            dplyr::select(fu_days_6months, removed_status_6months, FEMALE, 
                          log_MELD_BILIRUBIN, BILIRUBIN, 
                          MELD_SERUM_SODIUM, SERUM_SODIUM, 
                          log_MELD_INR, INR, 
                          log_MELD_SERUM_CREAT, SERUM_CREAT, 
                          MELD_ALBUMIN, ALBUMIN,  
                          log_AFP_trunc, AFP, tumortype), 
          type = "survival")[,"180"]
})
```

### Coefficients and variable importance

Coefficient estimates for Multi-HCC Cox PH model. 

```{r}
# Model of interest
my_model = "MELD 3.0 + log(AFP) + tumor burden (Multi-HCC)"

# Coefficient summary
summary(fit_coxph_6months[[my_model]])
```

Univariate HRs for each of the covariates in Multi-HCC. 

```{r}
# Covariates
my_covars = c("MELD3", "log(AFP_trunc)", "tumortype")

# Univariate Cox PH models
fit_coxph_univariate_6months = lapply(my_covars, function(my_covar) {
  coxph(as.formula(paste("Surv(fu_days_6months, removed_status_6months) ~", my_covar)), 
        data = HCC_train_df, x = TRUE)
})
do.call(
  rbind, 
  lapply(fit_coxph_univariate_6months, function(x) {
    cbind(summary(x)$coefficients, 
          as.data.frame(exp(confint(x))) %>% rename_with(~paste("exp(coef)", .x)))
  })
)
```

Variable importance for the random forest model. 

```{r, fig.width = 12}
# Wrapper that replaces variable names in VI plot with prettier labels
pretty_plot.rfsrc = function(rfsrc_vi) {
  rf_var_dict = c("FEMALE" = "Female", 
                  "MELD_BILIRUBIN" = "Bilirubin (MELD 3.0)", 
                  "BILIRUBIN" = "Bilirubin", 
                  "MELD_SERUM_SODIUM" = "Serum sodium (MELD 3.0)", 
                  "SERUM_SODIUM" = "Serum sodium", 
                  "MELD_INR" = "INR (MELD 3.0)", 
                  "INR" = "INR", 
                  "MELD_SERUM_CREAT" = "Serum creatinine (MELD 3.0)", 
                  "SERUM_CREAT" = "Serum creatinine", 
                  "MELD_ALBUMIN" = "Albumin (MELD 3.0)", 
                  "ALBUMIN" = "Albumin", 
                  "AFP" = "AFP", 
                  "AFP_trunc" = "log(truncated AFP)", 
                  "tumortypeT2.3.5" = "Tumor type: T2 3-5", 
                  "tumortypemultifocal" = "Tumor type: multifocal",
                  "tumortypeT3" = "Tumor type: T3")
  names(rfsrc_vi$importance)[
    match(names(rfsrc_vi$importance), names(rf_var_dict))] = rf_var_dict
  plot(rfsrc_vi)
}

pretty_plot.rfsrc(vimp_rf_6months)
```

## Rescale to MELD

We rescale the Multi-HCC predictions to MELD. To do this, fit a model to the 90-day outcome based on all patients in the training set, with an interaction between non-HCC patients and MELD 3.0, a main effect for HCC status, and an interaction between HCC and the linear predictor from the Multi-HCC Cox PH model. In other words, the predictions for non-HCC patients are based on only MELD 3.0, and the predictions for HCC patients are based on only the 6-month linear predictor (and HCC status). We then regress the MELD 3.0 scores against the linear predictor from this fit for non-HCC patients in the test set. 

```{r}
# Add linear predictor for 6-month model to train and test sets (non-HCC and HCC)
train_df$preds6months = 0
train_df$preds6months[train_df$HCC == TRUE] = 
  as.vector(predict(fit_coxph_6months[[my_model]], newdata = HCC_train_df))
test_df$preds6months = 0
test_df$preds6months[test_df$HCC == TRUE] = 
  as.vector(predict(fit_coxph_6months[[my_model]], newdata = HCC_test_df))

# Add variable that is an interaction between non-HCC and MELD3
# i.e. MELD3 for non-HCC and 0 for HCC
train_df = train_df %>% 
  mutate(nonHCC_MELD = (1-HCC)* MELD3)
test_df = test_df %>% 
  mutate(nonHCC_MELD = (1-HCC)* MELD3)

# Refit model to both HCC and non-HCC patients
fit_coxph_HCC_nonHCC_6months = coxph(
  Surv(fu_days_90days, removed_status_90days) ~ 
        nonHCC_MELD + HCC + HCC:preds6months, 
  data = train_df, x = TRUE)

# Add linear predictor from fit
train_df = train_df %>% 
  mutate(linpred_6months = predict(fit_coxph_HCC_nonHCC_6months, 
                                   newdata = train_df, type = "lp"))
test_df = test_df %>% 
  mutate(linpred_6months = predict(fit_coxph_HCC_nonHCC_6months, 
                                   newdata = test_df, type = "lp"))

# Regress MELD 3.0 against linear predictor for non-HCC patients
# Add rounded predictions as the final Multi-HCC score
fit_MELD3_lp_6months= lm(MELD3 ~ linpred_6months, 
                         data = test_df %>% filter(HCC == FALSE))
train_df = train_df %>% 
  mutate(multi_HCC = round(predict(fit_MELD3_lp_6months, newdata = train_df)),    
         diff_6months = multi_HCC - MELD3, 
         Cohort = ifelse(HCC == TRUE, "HCC", "Non-HCC"))
HCC_train_df = cbind(HCC_train_df, 
                     train_df %>% filter(HCC == TRUE) %>% dplyr::select(multi_HCC))
test_df = test_df %>% 
  mutate(multi_HCC = round(predict(fit_MELD3_lp_6months, newdata = test_df)),    
         diff_6months = multi_HCC - MELD3, 
         Cohort = ifelse(HCC == TRUE, "HCC", "Non-HCC"))
HCC_test_df = cbind(HCC_test_df, 
                    test_df %>% filter(HCC == TRUE) %>% dplyr::select(multi_HCC))

# Re-fit Multi-HCC Cox PH model using rescaled and rounded scores
refit_multi_HCC = coxph(
  Surv(fu_days_6months, removed_status_6months) ~ multi_HCC, 
  data = HCC_train_df, x = TRUE)
```

Visual checks for the proportional hazards assumption. 

```{r, fig.width = 5}
# KM plot up to 90 days for HCC and non-HCC patients
ggsurvplot(survfit(Surv(fu_days_90days, removed_status_90days) ~ Cohort, 
                   data = train_df %>% 
                     mutate(Cohort = ifelse(HCC == TRUE, "HCC", "Non-HCC"))), 
           legend.title = "", legend.labs = c("HCC", "Non-HCC"), 
           xlim = c(0, 90))
```

```{r, fig.height = 10}
# Schoenfeld residuals
p1 = ggcoxzph(cox.zph(fit_coxph_HCC_nonHCC_6months), font.main = 0)
grid.arrange(p1[[1]], p1[[2]], p1[[3]], ncol = 1)
```

Median number of points to add for each MELD 3.0 score. Error bars indicate the IQR, and those with MELD 3.0 above 30 are grouped together. 

```{r, fig.height = 8}
# Scatterplot of points to add against MELD
multi_HCC_med_df = test_df %>% 
  mutate(MELD3 = case_when(
    MELD3 >= 30 ~ 30, 
    TRUE ~ MELD3
  )) %>% 
  group_by(MELD3, Cohort) %>% 
  summarize(median = median(diff_6months, na.rm = T), 
            q1 = quantile(diff_6months, probs = 0.25, na.rm = T), 
            q3 = quantile(diff_6months, probs = 0.75, na.rm = T)) %>% 
  ungroup()

p1 = test_df %>% 
  mutate(MELD3 = case_when(
    MELD3 >= 30 ~ 30, 
    TRUE ~ MELD3
  )) %>% 
  group_by(MELD3, Cohort) %>% 
  summarize(median = median(diff_6months, na.rm = T), 
            q1 = quantile(diff_6months, probs = 0.25, na.rm = T), 
            q3 = quantile(diff_6months, probs = 0.75, na.rm = T)) %>% 
  ungroup() %>% 
  ggplot(aes(x = MELD3, y = median, color = Cohort)) + 
  geom_point(position = position_dodge(0.1)) + 
  # Re-plot HCC points to bring them to front
  geom_point(data = multi_HCC_med_df[multi_HCC_med_df$Cohort == "HCC", ], 
             aes(colour = Cohort)) + 
  geom_errorbar(aes(ymin=q1, ymax=q3), width = 0,
                 position = position_dodge(0.1)) + 
  scale_x_continuous(breaks = seq(6, 30, by = 1), limits = c(5.9, 30.1)) +
  ylim(-7, 7) + 
  geom_vline(xintercept = 17.5, color = "grey") +
  # geom_vline(xintercept = c(6, 10, 20, 30), color = "grey") +
  xlab("MELD 3.0") + ylab("Median number of points to add")

# Marginal histogram
p2 = test_df %>% 
  mutate(MELD3 = ifelse(MELD3 > 30, 30, MELD3)) %>% 
  ggplot(aes(x = MELD3, fill = Cohort)) +
  geom_histogram(color = "black", alpha = 0.6, 
                 position = "identity", binwidth = 1) + 
  theme_void() +
  theme(legend.position = "none", 
        plot.margin = unit(c(3, 29, 0, 8.5), "mm"))
grid.arrange(p2, p1, nrow = 2, ncol = 1, widths = 7, heights = c(3, 7))
```

Histogram of Multi-HCC score among HCC patients, shaded by risk quartile. 

```{r, fig.width = 5}
quartile_label = c("1 (Low)", "2", "3", "4 (High)")
test_df %>% 
  filter(HCC == TRUE) %>% 
  mutate(quant = cut(multi_HCC, breaks = quantile(multi_HCC))) %>% 
  drop_na(quant) %>% 
  ggplot(aes(x = multi_HCC, fill = factor(quant, levels = levels(quant)))) + 
  geom_histogram(color = "black", binwidth = 1) + 
  scale_fill_discrete(name = NULL, labels = paste("Quartile", quartile_label)) + 
  xlab("Multi-HCC") + ylab("Count") + 
  theme(legend.position = "bottom")
```

We plot the 90-day survival probability of non-HCC patients with a given MELD 3.0 score against the 90-day survival probability of HCC patients with the same-valued Multi-HCC score. 

```{r, fig.width = 6.5}
# Add variable that is an interaction between HCC and and Multi-HCC
# i.e. the Multi-HCC score for HCC and 0 for non-HCC
train_df = train_df %>% 
  mutate(HCC_preds6months = HCC* preds6months)
test_df = test_df %>% 
  mutate(HCC_preds6months = HCC* preds6months)

# Refit model to both HCC and non-HCC patients, using the hard-coded interactions
fit_coxph_HCC_nonHCC_6months2 = coxph(
  Surv(fu_days_90days, removed_status_90days) ~ 
        nonHCC_MELD + HCC + HCC_preds6months, 
  data = train_df, x = TRUE)

data.frame(
  test_df, 
  surv = t(summary(survfit(fit_coxph_HCC_nonHCC_6months2, 
                                 newdata = test_df), times = 90)$surv)) %>% 
  mutate(
    # Use Multi-HCC score for HCC, MELD 3.0 for non-HCC
    composite_score = case_when(
      HCC == TRUE ~ multi_HCC, 
      HCC == FALSE ~ MELD3, 
      TRUE ~ NA), 
    # Round score
    composite_score_rounded = round(composite_score)) %>% 
  # Keep only scores between 6 and 40
  filter(composite_score_rounded >= 6 & composite_score_rounded <= 40) %>% 
  # Keep observations that are closest to the rounded score
  group_by(composite_score_rounded, HCC) %>% 
  arrange(abs(composite_score_rounded - composite_score)) %>% 
  summarize(surv = first(surv)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = HCC, values_from = surv) %>% 
  ggplot(aes(x = `0`, y = `1`, color = composite_score_rounded)) + 
  geom_point() + 
  geom_abline(intercept = 0, slope = 1, color = "grey") + 
  viridis::scale_color_viridis("MELD 3.0 or\nmulti-HCC", option = "D")+
  scale_x_log10() + scale_y_log10() + 
  xlim(0, 1) + ylim(0, 1) + 
  xlab("MELD 3.0 (non-HCC patients)") + ylab("Multi-HCC (HCC patients)")
```

### Formula for HCC patients, aligned with MELD

This is the risk prediction formula for HCC patients, re-scaled to be aligned with MELD: 

```{r}
# Coefficients from fitting MELD 3.0 against linear predictor 
lp_intercept_6months = coef(fit_MELD3_lp_6months)["(Intercept)"]
lp_slope_6months = coef(fit_MELD3_lp_6months)[("linpred_6months")]

# coxph function centers variables, so this is the linear shift to subtract 
# off of the linear predictor
my_shift_6months = sum(coef(fit_coxph_HCC_nonHCC_6months) * 
                         fit_coxph_HCC_nonHCC_6months$means)

# Cox PH coefficient to rescale 6-month linear predictor
coxph_slope = coef(fit_coxph_HCC_nonHCC_6months)["HCC:preds6months"]
# Shift for the second Cox PH model (fit to the linear predictor)
coxph_shift = sum(coef(fit_coxph_6months[[my_model]]) * 
                    fit_coxph_6months[[my_model]]$means)

# Intercept for HCC patients
my_intercept_6months = lp_intercept_6months + lp_slope_6months * 
  (coef(fit_coxph_HCC_nonHCC_6months)["HCC"] - my_shift_6months - 
     coxph_slope * coxph_shift)
# Coefficients for HCC patients
my_coefs_6months = lp_slope_6months * coxph_slope *
  coef(fit_coxph_6months[[my_model]])
names(my_coefs_6months) = c("MELD3", "log(AFP)", "[T2 3-5]", "[multifocal]", "[T3]")

# Final formula
paste(c(round(my_intercept_6months, 3), sapply(names(my_coefs_6months), function(x) {
  paste0(round(my_coefs_6months[x], 3), "*", x)
})), collapse = " + ")
```

## Descriptive and miscellaneous stats

"Table 1" of cohort characteristics. 

```{r}
table1 = CreateTableOne(
  c("Age, years", "Sex", "MELD", "MELD-Na", "MELD 3.0", 
    "Serum bilirubin", "Serum INR", "Serum creatinine", "Serum albumin", 
    "Serum sodium", "AFP, ng/mL", "Categorical AFP", "Tumor type", 
    "History of LRT"), 
  data = rbind(train_df %>% mutate(set = "Development"), 
               test_df  %>% mutate(set = "Validation")) %>% 
    mutate("Age, years" = INIT_AGE, 
           Sex = fct_recode(GENDER, male = "M", female = "F"), 
           "MELD-Na" = MELDNA, 
           "MELD 3.0" = MELD3, 
           "Serum bilirubin" = BILIRUBIN, 
           "Serum INR" = INR, 
           "Serum creatinine" = SERUM_CREAT, 
           "Serum albumin" = ALBUMIN, 
           "Serum sodium" = SERUM_SODIUM, 
           "AFP, ng/mL" = AFP, 
           "Categorical AFP" = factor(
             case_when(AFP <= 20 ~ "≤20", 
                       AFP <= 40 ~ "21-40", 
                       AFP <= 250 ~ "41-250", 
                       AFP > 250 ~ "250+", 
                       TRUE ~ NA), 
             levels = c("≤20", "21-40", "41-250", "250+")),   
           "Tumor type" = fct_recode(tumortype, 
                                     "T1/T2 2-3 cm" = "T1, T2 2-3", 
                                     "T2 3-5 cm" = "T2 3-5", 
                                     "T2 multifocal" = "multifocal", 
                                     "T3 (downstaged)" = "T3"), 
           "History of LRT" = ifelse(historyLRT == 1, "Yes", "No")), 
  strata = "set", 
  test = FALSE, 
  smd = FALSE, 
  addOverall = TRUE)

print(table1, 
      # Median [IQR] instead of mean (SD)
      nonnormal = c("Age, years", "MELD", "MELD-Na", "MELD 3.0", 
                    "Serum bilirubin", "Serum INR", "Serum creatinine", 
                    "Serum albumin", "Serum sodium", "AFP, ng/mL"))
```

Overall outcomes among HCC patients. 

```{r}
    # 8 is death, 13 is dropout and 4/15/21 are transplanted
# 11018 (60.4%) patients were removed for deceased donor liver transplant; 315 (1.7%) for living donor liver transplant, 957 (5.2%) for death, and 2619 (14.4%) for being too sick. 
df %>% 
  filter(HCC == TRUE) %>% 
  mutate(removal_reason = factor(case_when(
    REM_CD == 4 ~ "Deceased donor liver transplant", 
    REM_CD == 15 ~ "Living donor liver transplant", 
    REM_CD == 8 ~ "Death", 
    REM_CD == 13 ~ "Too sick", 
    TRUE ~ NA
  ), levels = c("Deceased donor liver transplant", 
                "Living donor liver transplant", 
                "Death", "Too sick"))) %>% 
  count(removal_reason) %>% 
  mutate(val = paste0(n, " (", round(100*prop.table(n), 1), "%)")) %>% 
  drop_na() %>% 
  dplyr::select("Removal reason" = removal_reason, "n (%)" = val)
```

Overall waiting list dropout at 90 days, 6 months, and 1 year among validation set patients with HCC, estimated using Kaplan-Meier. 

```{r}
tibble(
  Time = c("90 days", "6 months", "1 year"), 
  "Overall waitlist dropout" = 
    paste0(round(100 * (1 - summary(
      survfit(Surv(fu_days_1year, removed_status_1year) ~ 1, data = HCC_test_df), 
      times = c(90, 180, 365))$surv), 1), "%")
)
```

Observed risk of waiting list dropout at 6 months for each Multi-HCC quartile in the validation set, estimated using Kaplan-Meier. 

```{r}
HCC_test_df = HCC_test_df %>% 
  mutate(quant = cut(multi_HCC, breaks = quantile(multi_HCC)))

tibble(
  Quartile = c("1 (Low)", "2", "3", "4 (High)"), 
  "Median Multi-HCC" = tapply(HCC_test_df$multi_HCC, HCC_test_df$quant, median), 
  "Observed risk of waitlist dropout" = paste0(round(100 * (1 - summary(
    survfit(Surv(fu_days_6months, removed_status_6months) ~ quant, 
            data = HCC_test_df), 
    times = 180)$surv), 1), "%")
) %>% `rownames<-`(NULL)
```

Kaplan-Meier plot of 5-year post-transplant survival among patients in each Multi-HCC risk quartile. 

```{r}
quartile_label = c("1 (Low)", "2", "3", "4 (High)")
HCC_test_5year_df <- HCC_test_df %>% filter(!is.na(PX_STAT_DATE)) %>%
  mutate(Quartile = factor(quant, labels = ), 
         time_tx_px = as.numeric(PX_STAT_DATE-TX_DATE), 
         fail5year = ifelse(PX_STAT=="D" & time_tx_px < 1825, 1, 0))

coxph_5year = survfit(Surv(time_tx_px, fail5year) ~ Quartile, data = HCC_test_5year_df)
ggsurvplot(coxph_5year, data = HCC_test_5year_df, 
           legend.title = "", legend.labs = paste("Quartile", quartile_label),
           risk.table = FALSE, censor = FALSE, pval = TRUE, 
           pval.coord = c(90, 0.6), conf.int = FALSE, 
           xlim = c(0, 1800), ylim = c(0.5, 1.0), 
           break.time.by = 365, risk.table.y.text.col = FALSE)
```

5-year post-transplant survival among validation patients with Multi-HCC 16-19, 20-23, and above 24, estimated using Kaplan-Meier. 

```{r}
tibble(
  "Multi-HCC" = c("16-19", "20-23", "≥24"), 
  "5-year post-transplant survival" = sapply(
    list(survfit(Surv(time_tx_px, fail5year) ~ 1, 
                 data = HCC_test_5year_df %>% 
                   filter(multi_HCC >= 16, multi_HCC <= 19)), 
         survfit(Surv(time_tx_px, fail5year) ~ 1, 
                 data = HCC_test_5year_df %>% 
                   filter(multi_HCC >= 20, multi_HCC <= 23)), 
         survfit(Surv(time_tx_px, fail5year) ~ 1, 
                 data = HCC_test_5year_df %>% 
                   filter(multi_HCC >= 24))),
    function(x) {
      paste0(round(100 * summary(x, times = 5*365)$surv, 1), "%")
    })
)
```

## Concordance, integrated Brier scores, and calibration

We use a bootstrap routine to obtain 95% confidence intervals for each 6-month model's test concordance and integrated Brier score (multi-HCC only).  

```{r}
# All other scores, applied to test set
scores_test = cbind(
  pred_coxph_6months[,1:2], 
  "MELD 3.0 + log(AFP) + tumor burden (Multi-HCC)" = HCC_test_df$multi_HCC, 
  "Random survival forest" = pred_rf_6months$predicted, 
  "Gradient boosting model" = pred_gbm_6months, 
  data.frame(1 - preds_pycox_6months) %>% 
    setNames(c("DeepHit", "DeepSurv")), 
  HCC_test_df %>% 
    dplyr::select(Mehta, `HALT-HCC` = HALT_HCC, deMELD, 
                  `HCC-MELD` = HCC_MELD, `MELD-Eq` = MELD_Eq))

# Restrict to patients waitlisted after May 14 2019
# INIT_DATE = Beginning date for registration (in liver data)
HCC_test_20190514_df = HCC_test_df %>% 
  filter(INIT_DATE > as.Date("2019-05-14"))
```

```{r, echo = FALSE}
load("boot_diagnostics.rData")
```

```{r, eval = FALSE}
# Number of bootstraps
B = 1000

# For some reason, you need to run this line-by-line using Command + Enter
# Running chunk by clicking the little green arrow or copy-pasting to the 
# terminal seems to cause it to hang
# When parallelized to 8 cores, takes ~6 minutes
boot_diagnostics = foreach::foreach(
  b = 1:B, .packages = c("tidyverse", "survival", "randomForestSRC", "gbm", 
                         "survivalmodels", "pec")
  ) %do% {
  # Set seed
  set.seed(b)
  # Create bootstrap sample of test set
  boot_idx = sample(nrow(HCC_test_df), replace= TRUE)
  boot_HCC_test_df = HCC_test_df[boot_idx,]
  HCC_test_20190514_test_df = HCC_test_20190514_df[boot_idx,]
  boot_scores_test = scores_test[boot_idx,]
  
  # Concordance for each outcome
  concordance_est = apply(boot_scores_test, 2, function(pred) {
    if(all(is.na(pred))) {
      return(NA)
    }
    concordance(Surv(fu_days_6months, removed_status_6months) ~ pred, 
                data.frame(pred = pred,
                           boot_HCC_test_df %>% 
                             dplyr::select(fu_days_6months, 
                                           removed_status_6months)), 
                reverse = TRUE)$concordance
    })
  
  # Sensitivity concordance restricting to patients who were waitlisted after 
  # May 14, 2019. 
  concordance_est_20190514 = 
    concordance(Surv(fu_days_6months, removed_status_6months) ~ multi_HCC, 
                HCC_test_20190514_test_df, 
                reverse = TRUE)$concordance
  
  # Integrated Brier score for 6 months only
  brier_est = crps(pec(object = refit_multi_HCC, 
                       formula = Surv(fu_days_6months, removed_status_6months) ~ 1, 
                       data = boot_HCC_test_df))[-1,]
  
  return(list(concordance_est = concordance_est, 
              concordance_est_20190514 = concordance_est_20190514, 
              brier_est = brier_est))
}

save(boot_diagnostics, file = "boot_diagnostics.rData")
```

We report the test concordance for each model with a 95% bootstrap CI and p-values for a significant difference from Multi-HCC. All p-values reported have been adjusted using the Holm correction. 

```{r}
# Point estimates for concordance
concordance_est = apply(scores_test, 2, function(pred) {
  concordance(Surv(fu_days_6months, removed_status_6months) ~ pred, 
              data.frame(pred = pred,
                         HCC_test_df %>% 
                           dplyr::select(fu_days_6months, 
                                         removed_status_6months)), 
              reverse = TRUE)$concordance
  })

# Concordance 2.5%
concordance_lo = 
  apply(sapply(boot_diagnostics, function(x){x$concordance_est}), 
        1, quantile, 0.025, na.rm = TRUE)
# Concordance 97.5%
concordance_hi = 
  apply(sapply(boot_diagnostics, function(x){x$concordance_est}), 
        1, quantile, 0.975, na.rm = TRUE)

# Table of concordance statistics with 95% CI
concordance_tab = data.frame(
  paste0(round(concordance_est, 3), " (", 
         round(concordance_lo, 3), ", " ,
         round(concordance_hi, 3), ")")
) %>% setNames("C-statistic") %>% 
  `rownames<-`(names(concordance_est))

# Compare 6-month model to MELD 3.0, best-performing ML model (GBM), 
# and to all previous scores
pvals_6months = sapply(scores_test[,-3], function(pred) {
  compareC(HCC_test_df$fu_days_6months, 
           HCC_test_df$removed_status_6months, 
           HCC_test_df$multi_HCC, 
           pred)$pval
})

# Adjust all p-values (Holm's adjustment)
pvals_adj = p.adjust(pvals_6months)
data.frame(concordance_tab[c("MELD 3.0 + log(AFP) + tumor burden (Multi-HCC)", 
                             names(pvals_6months)), , drop = FALSE], 
           c("", round(pvals_adj[names(pvals_6months)], 4))) %>% 
  setNames(c("C-statistic (95% CI)", "Adjusted p-value"))
```

As a sensitivity check, we calculate the Multi-HCC C-statistic when restricting to patients who were waitlisted after May 14, 2019. 

```{r}
# Point estimates for concordance
concordance_est_20190514 = 
  concordance(Surv(fu_days_6months, removed_status_6months) ~ multi_HCC, 
              HCC_test_20190514_df, 
              reverse = TRUE)$concordance

# Concordance 2.5%
concordance_lo_20190514 = quantile(
  sapply(boot_diagnostics, function(x){x$concordance_est_20190514}), 
  0.025, na.rm = TRUE)
# Concordance 97.5%
concordance_hi_20190514 = quantile(
  sapply(boot_diagnostics, function(x){x$concordance_est_20190514}), 
  0.975, na.rm = TRUE)

# Table of concordance statistics with 95% CI
paste0(round(concordance_est_20190514, 3), " (", 
       round(concordance_lo_20190514, 3), ", " ,
       round(concordance_hi_20190514, 3), ")") 
```

We report the test integrated Brier score for Multi-HCC with a 95% bootstrap CI. 

```{r}
# Point estimates for integrated Brier score
brier_est = crps(pec(object = refit_multi_HCC, 
                     formula = Surv(fu_days_6months, removed_status_6months) ~ 1, 
                     data = HCC_test_df))[-1,]

# Brier score 2.5%
brier_lo = quantile(sapply(boot_diagnostics, function(x){x$brier_est}), 
                    0.025, na.rm = TRUE)
# Brier score 97.5%
brier_hi = quantile(sapply(boot_diagnostics, function(x){x$brier_est}), 
                    0.975, na.rm = TRUE)

# Brier score with 95% CI
paste0(round(brier_est, 3), " (", 
         round(brier_lo, 3), ", " ,
         round(brier_hi, 3), ")")
```

Calibration plot for multi-HCC: the test set is divided into quartiles based on 6-month survival probability. The lines represent the Kaplan-Meier curves for these quartiles, with confidence intervals shaded. The points are averaged over all predicted survival probabilities for individuals in the quartile, at a given time point. 

```{r, fig.width = 4.5}
# Number of survival probability bins
n_timepoints = 10

# Get test survival probabilities for 6-month model
surv_6months_mat = summary(survfit(fit_coxph_6months[[my_model]], newdata = HCC_test_df), 
                          times = seq(0, 180, length = n_timepoints))$surv
# Divide test set into quartiles based on probability at 6 months 
quart_thresh_6months = quantile(surv_6months_mat[nrow(surv_6months_mat),], 
                                seq(0.25, 0.75, by = 0.25))
quart_6months = rev(1:(length(quart_thresh_6months)+1))[
  as.numeric(cut(surv_6months_mat[nrow(surv_6months_mat),], 
                 breaks = c(-Inf, as.numeric(quart_thresh_6months), Inf)))]

# Data frame for plotting calibration
calib_6months_df = data.frame(
  Quartile = factor(rep(4:1, each = n_timepoints)), 
  time = rep(seq(0, 180, length = n_timepoints), times = 4), 
  surv = as.vector(sapply(4:1, function(i) {
    rowMeans(surv_6months_mat[,quart_6months == i])
  })), 
  surv_se = as.vector(sapply(4:1, function(i) {
    apply(surv_6months_mat[,quart_6months == i], 1, sd)
  })))

# Kaplan-Meier plot
p_km_6months = ggsurvplot(survfit(Surv(fu_days_6months, removed_status_6months) ~ 
                                    quart_6months, data = HCC_test_df), 
                          legend.title = "", 
                          legend.labs = paste("Quartile", quartile_label),
                          censor = FALSE, conf.int = TRUE) 

# KM plot with predicted survival probabilities for each quartile
p_km_6months$plot +
  geom_point(
    data = calib_6months_df, 
    aes(x = time, y = surv, 
        color = Quartile)) + 
  scale_color_manual(values = rep(scales::hue_pal()(4), 2)) + 
  coord_cartesian(ylim = c(0.65, 1)) + 
  guides(color = "none", 
         fill = guide_legend(override.aes = list(alpha = 1), ncol = 2)) + 
  theme(legend.position = "bottom")
```
