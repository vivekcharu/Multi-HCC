---
title: "HCC modeling"
output: html_document
date: "2024-07-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
library(tidyverse)
library(haven)
library(abind)
library(survminer)
library(gridExtra)
library(compareC)

library(survival)
library(randomForestSRC)
library(gbm)
library(survivalmodels)
library(pec)
library(mgcv)

library(foreach)
library(doParallel)

# Cluster object
cl = parallel::makeCluster(parallel::detectCores() - 2)
# Register parallel backend
registerDoParallel(cl)

# Force rfsrc to use 1 core/no parallelization
# Keeps things from exploding during parallelized bootstrap
# Doesn't seem to be working anymore
options(mc.cores = 1, rf.cores = 1)

# Set background to be white for all ggplots
theme_set(theme_classic())
```

## Data processing

First, we read in the data. 

```{r}
# Data directory
dir = "/Users/jliang/Library/CloudStorage/Box-Box/HCC\ modeling/Data/"

# Read in data
liverdata = read_sas(paste0(dir, "liver_data.sas7bdat"))
exceptiondata = read_sas(paste0(dir, "liver_exception_data.sas7bdat"))
wlhxdata = read_sas(paste0(dir, "liver_wlhistory_data.sas7bdat"))
```

The cohort is defined as adult patients with initial exception between October 8, 2015 and December 31, 2022. Non-HCC patients are those who are not in the exception list.

```{r}
cohort = liverdata %>% 
  dplyr::select(-HCC_DIAG) %>% 
  # Join initial exception date
  left_join(
    exceptiondata %>% 
      group_by(WL_ID_CODE) %>% 
      arrange(BEGIN_DATE) %>% 
      dplyr::slice(1) %>%
      ungroup() %>% 
      dplyr::select(WL_ID_CODE, BEGIN_DATE, HCC_DIAG, CASE_OUTCOME), 
    by = "WL_ID_CODE") %>% 
  filter(
    # Adults
    INIT_AGE >= 18, 
    # Has HCC
    # Has HCC diagnosis and this is the first approved HCC exception
    # (Hepatoma – Hepatocellular Carcinoma) or 4401 (Hepatoma (HCC) and Cirrhosis
    ((HCC_DIAG != "" & CASE_OUTCOME == "Request Approved" ) & 
       # with initial exception between October 8, 2015 and December 31, 2022
       BEGIN_DATE >= as.Date("2015-10-8") & BEGIN_DATE <= as.Date("2022-12-31")) |
      # Or is non-HCC (not in exception list)
      (!(WL_ID_CODE %in% exceptiondata$WL_ID_CODE) & 
         # Exclude previous transplants 
         (PREV_TX != "Y" & (NUM_PREV_TX < 1 | is.na(NUM_PREV_TX))) & 
         # Exclude multiorgan other than liver kidney
         (WLHL != "Y "& WLHL != "Y" & WLLU != "Y" & WLIN != "Y") & 
         # With initial date between October 8, 2015 and December 31, 2022
         (INIT_DATE >= as.Date("2015-10-08") & INIT_DATE <= as.Date("2022-12-31")))) %>% 
  mutate(HCC = replace_na(
    ifelse(HCC_DIAG != "" & CASE_OUTCOME == "Request Approved", 1, 0), 0))
```

Using the exception and waitlist history data, we extract the MELD 3.0 components, AFP and tumor type for HCC patients are taken as close to the initial exception date as possible. MELD 3.0 components must be with 90 days of initial exception. 

```{r}
# Liver exception data
exception = exceptiondata %>% 
  filter(WL_ID_CODE %in% cohort$WL_ID_CODE & # Restrict to cohort
           !is.na(BEGIN_DATE)) %>% # Non-missing start date for exception
  right_join(cohort %>% dplyr::select(WL_ID_CODE, INIT_DATE), 
             by="WL_ID_CODE") %>% # Merge in initial listing date
  group_by(WL_ID_CODE) %>% 
  arrange(BEGIN_DATE) %>% 
  # Has HCC diagnosis and this is the first approved HCC exception
  filter(HCC_DIAG != "" & CASE_OUTCOME == "Request Approved") %>%      
  # Time since listing
  mutate(wltime = as.numeric(BEGIN_DATE - INIT_DATE)) %>% 
  # Keep observation closest to listing time
  dplyr::slice(1) %>% 
  # Replace NA with 0 
  mutate_at(vars(c("ORIG_TUMOR_SIZE1", "ORIG_TUMOR_SIZE2", "ORIG_TUMOR_SIZE3",
                   "ORIG_TUMOR_SIZE4", "ORIG_TUMOR_SIZE5", "TUMOR_SIZE1", 
                   "TUMOR_SIZE2", "TUMOR_SIZE3", "TUMOR_SIZE4", "TUMOR_SIZE5")), 
            ~ifelse(is.na(.), 0, .)) %>%
  mutate(
    # Find the largest tumor size
    largesttumor = pmax(TUMOR_SIZE2, TUMOR_SIZE1, TUMOR_SIZE3, TUMOR_SIZE4, TUMOR_SIZE5), 
    # Sum of all tumor sizes
    TTS = TUMOR_SIZE1 + TUMOR_SIZE2 + TUMOR_SIZE3 + TUMOR_SIZE4 + TUMOR_SIZE5, 
    # Define outsideMilan based on number of tumors + tumor size
    outsideMilan = replace_na(
      ifelse((TUMORNUM == 1 & TUMOR_SIZE1 > 5) | 
               (TUMORNUM >= 2 & (TUMOR_SIZE1 > 3 | TUMOR_SIZE2 > 3 | TUMOR_SIZE3 > 3)) | 
               TUMORNUM > 3, 1, 0), 0), 
    # Define some more variables based on tumor info
    solitaryHCC = ifelse(TUMORNUM == 1 & TUMOR_SIZE1 <= 3, 1 ,0), 
    # Total number of tumors
    total_tumor_num = (ORIG_TUMOR_SIZE1 > 1) + (ORIG_TUMOR_SIZE2 > 1) + 
      (ORIG_TUMOR_SIZE3 > 1) + (ORIG_TUMOR_SIZE4 > 1) + (ORIG_TUMOR_SIZE5 > 1), 
    # T1: none or < 2 cm of tumor (presumably already treated)
    T1 = (TUMORNUM == 0) | ( TUMORNUM == 1 & TUMOR_SIZE1 < 2), 
    T1_dx = (total_tumor_num == 0) | ( total_tumor_num == 1 & ORIG_TUMOR_SIZE1 < 2), 
    # T2: single solitary tumor 2-3 cm
    single_tumor_2_3 = TUMORNUM == 1 & TUMOR_SIZE1 >= 2 & TUMOR_SIZE1 <= 3, 
    T2_dx_2_3 = total_tumor_num == 1 & ORIG_TUMOR_SIZE1 >= 2 & ORIG_TUMOR_SIZE1 <= 3, 
    # T2: single large tumor >3 cm and ≤5 cm
    single_tumor_3_5 = TUMORNUM == 1 & TUMOR_SIZE1 > 3 & TUMOR_SIZE1 <= 5, 
    T2_dx_3_5 = total_tumor_num == 1 & ORIG_TUMOR_SIZE1 > 3 & ORIG_TUMOR_SIZE1 <= 5, 
    # T2: multifocal
    T2_multifocal = 
      (total_tumor_num == 2  & ORIG_TUMOR_SIZE1 >= 1 & ORIG_TUMOR_SIZE1 <= 3 & 
         ORIG_TUMOR_SIZE2 >= 2 & ORIG_TUMOR_SIZE2 <= 3) | 
      (total_tumor_num == 3 & ORIG_TUMOR_SIZE1 >= 1 & ORIG_TUMOR_SIZE1 <= 3 & 
         ORIG_TUMOR_SIZE2 >= 1 & ORIG_TUMOR_SIZE2 <= 3 & 
         ORIG_TUMOR_SIZE3 >= 1 & ORIG_TUMOR_SIZE3 <= 3),
    # T3: single tumor > 5 cm or >3 tumors
    T3 = replace_na(
      ifelse((TUMORNUM == 1 & TUMOR_SIZE1 > 5) | 
               (TUMORNUM >= 2 & (TUMOR_SIZE1 > 3 | TUMOR_SIZE2 > 3 | TUMOR_SIZE3 > 3)) | 
               TUMORNUM > 3, 1, 0), 0), 
    multifocal_2_3 = TUMORNUM %in% c(2, 3) & T3 == 0, 
    T3_dx = !T1_dx & !T2_dx_2_3 & !T2_dx_3_5 & !T2_multifocal, 
    # Tumor type
    tumortype = case_when( 
      T1 == TRUE | single_tumor_2_3 == TRUE ~ "T1, T2 2-3", 
      single_tumor_3_5 == TRUE ~ "T2 3-5", 
      multifocal_2_3 == TRUE ~ "multifocal", 
      T3 == 1 ~ "T3"), 
    tumortype=ifelse(T1==TRUE & T3_dx==TRUE,"T3",tumortype), 
    tumortype=ifelse(T1==TRUE & T2_dx_2_3==TRUE,"T1, T2 2-3",tumortype), 
    tumortype=ifelse(T1==TRUE & T2_dx_3_5==TRUE,"T2 3-5",tumortype), 
    tumortype=ifelse(T1==TRUE & T2_multifocal==TRUE,"multifocal",tumortype), 
    # AFP categories
    AFPcat = case_when(
      AFP <= 20 ~ "<=20", 
      AFP > 20 & AFP <= 40 ~ "21-40", 
      AFP > 40 & AFP <= 400 ~ "41-400", 
      AFP > 400 ~ "401+"), 
    # Previous treatment
    historyLRT = replace_na(ifelse(
      first(TREAT_DATE1) < BEGIN_DATE | 
        first(TREAT_DATE2) < BEGIN_DATE | 
        first(TREAT_DATE3) < BEGIN_DATE, 
      1 , 0), 0), 
    ) %>% 
  ungroup()

# Liver waitlist history data
wlhx = wlhxdata %>% 
  filter(WL_ID_CODE %in% cohort$WL_ID_CODE) %>% # Subset cohort
  right_join(cohort %>% dplyr::select(WL_ID_CODE, BEGIN_DATE), 
             by="WL_ID_CODE") %>% # Merge in initial exception date
  group_by(WL_ID_CODE) %>% 
  arrange(CHG_DATE) %>% # Order by waitlist modification date
  # Days between waitlist modification and initial exception
  mutate(wltime = as.numeric(CHG_DATE - BEGIN_DATE)) %>% 
  # Filter out observations that are more than +/- 90 day of initial exception
  filter(wltime > -90, wltime < 90) %>% 
  # Keep observation closest to listing time
  dplyr::slice(which.min(abs(wltime))) %>% 
  ungroup()
```

Join all data together and define outcomes for time to waitlist removal or death within 90 days/6 months/one year, censored at time of transplant or administrative censoring at 90 days/6 months/one year. Non-HCC patients will not have AFP or tumor variables (only dummy values filled in), but these variables wil only contribute to the HCC predictions.

```{r}
# Calculate MELD
calc_meld = function(bilirubin, inr, creat) {
  9.57 * log(creat) + 3.78 * log(bilirubin) + 11.20 * log(inr) + 6.43
}

# Calculate MELD-Na
calc_meldna = function(meld, na) {
  meld + 1.32 * (137 - na) - (0.033 * meld * (137 - na))
}

# Calculate MELD 3.0 (Kim et al., 2021)
calc_meld3 = function(female, bilirubin, na, inr, creat, alb) {
  round(1.33 * female + 4.56 * log(bilirubin) + 0.82 * (137 - na) - 
          0.24 * (137 - na) * log(bilirubin) + 9.09 * log(inr) + 
          11.14 * log(creat) + 1.85 * (3.5 - alb) - 
          1.83 * (3.5 - alb) * log(creat) + 6)
}

# Child-Pugh score
# ascites: 1 = Absent, 2 = Slight, 3 = Moderate, 4 = N/A
# enceph: 1 = None, 2 = 1-2, 3 = 3-4, 4 = N/A
calc_child_pugh = function(bilirubin, inr, alb, ascites, enceph) {
  ((bilirubin < 2) + (alb > 3.5) + (inr < 1.7) + (ascites == 1 | ascites == 4) + 
     (enceph == 1 | enceph == 4)) + 
    2 * ((bilirubin >= 2 & bilirubin <= 3) + (alb >= 2.8 & alb <= 3.5) + 
           (inr >= 1.7 & inr <= 2.3) + (ascites == 2) + (enceph == 2)) +
    3 * ((bilirubin > 3) + (alb < 2.8) + (inr > 2.3) + (ascites == 3) + (enceph == 3))
}

# Neil Mehta's score
calc_mehta = function(meld3, child_pugh, afp, tumor_num, tumor_size1) {
  (meld3 - 10) + ((child_pugh - 5) * 3) + 5 * (afp > 21 & afp <= 40) + 
    9 * (afp > 40 & afp <= 500) + 20 * (afp > 500 & afp <= 1000) + 
    23 * (afp > 1000) + 6 * (tumor_num == 1 & tumor_size1 >= 3.1 & tumor_size1 <= 6) + 
    5 * (tumor_num >= 2 & tumor_num <= 3)
}

# HALT-HCC
# size, defined by the Pythagorean theorem
calc_halt_hcc = function(meldna, afp, tbs) {
  (1.27 * tbs) + (1.85 * log(afp)) + (0.26 * meldna)
}

# deMELD
# Cause of liver disease?
calc_demeld = function(age, meld, afp, tumor_num, tumor_size, 
                       hepb, alcohol, nash, hemochrom) {
  -25 + (0.1 * age) + (1.6 * meld) + (1.6 * tumor_size) + 
    (1.3 - log(afp)) + 6 * (tumor_num > 2) - 
    (hepb == 1) + 3 * (alcohol == 1) + 3 * (nash == 1) + 
    (hemochrom == 1)
}

# HCC-MELD
calc_hcc_meld = function(meld, afp) {
  1.27 * meld - 0.51 * log(afp) + 4.59
}

# MELD-Eq
calc_meld_eq = function(meld, afp, tumor_num, tumor_size_max, wl_drop_months) {
  pmax(meld, 1.143 * meld + 1.324 * log(afp) + 1.438 * tumor_num + 
         1.194 * tumor_size_max - 2/0.146 * (wl_drop_months < 6) - 
         1/0.146 * (wl_drop_months >= 6))
}

# ALBI
calc_albi = function(bilirubin, alb) {
  # Multiply by 17.1 to convert mg/dL to umol/L
  # Multiply by 10 to convert g/dl to g/l
  0.66 * log10(17.1 * bilirubin) - 0.085 * alb * 10
}

df = cohort %>% 
    dplyr::select(WL_ID_CODE, INIT_DATE, REM_CD, END_DATE, TX_DATE,
                  PX_STAT_DATE, PX_STAT, INIT_AGE, GENDER, DAYSWAIT_CHRON, 
                  DGN_TCR, DGN2_TCR, HCC_EVER_APPR, EVER_APPROVED, 
                  CASE_OUTCOME, HCC, INIT_DIALYSIS_PRIOR_WEEK, INIT_BILIRUBIN, 
                  INIT_INR, INIT_ALBUMIN, INIT_SERUM_CREAT, INIT_SERUM_SODIUM, 
                  INIT_ASCITES, INIT_ENCEPH) %>% 
  left_join(
    exception %>% 
      dplyr::select(-(CONTRAST1:WASHOUT8), -(TREAT1:ULTSND_DATE5), -(TACE:ABLATE), -INIT_DATE), 
    by = "WL_ID_CODE") %>% 
  left_join(
    wlhx %>% dplyr::select(WL_ID_CODE, BILIRUBIN, INR, ALBUMIN, SERUM_CREAT, 
                           SERUM_SODIUM, ASCITES, ENCEPH, CHG_DATE, 
                           DIALYSIS_PRIOR_WEEK, wltime, MELD_PELD_LAB_SCORE), 
    by = "WL_ID_CODE"
  ) %>% 
  mutate(
    # Set AFP and tumor variables to 0 for non-HCC patients 
    # (these are all just decoys)
    AFP = ifelse(HCC == TRUE, AFP, 0), 
    AFPcat = ifelse(HCC == TRUE, AFPcat, "<=20"), 
    tumortype = factor(ifelse(HCC == TRUE, tumortype, "T1, T2 2-3"), 
                       levels = c("T1, T2 2-3", "T2 3-5", "multifocal", "T3")), 
    historyLRT = ifelse(HCC == TRUE, historyLRT, 0), 
    # Female
    FEMALE = GENDER == "F", 
    # Coalesce lab values for non-HCC (from liver file, prefixed INIT) with 
    # lab values for HCC (from waitlist file, closest to date)
    BILIRUBIN = coalesce(BILIRUBIN, INIT_BILIRUBIN), 
    INR = coalesce(INR, INIT_INR), 
    ALBUMIN = coalesce(ALBUMIN, INIT_ALBUMIN), 
    SERUM_CREAT = coalesce(SERUM_CREAT, INIT_SERUM_CREAT), 
    SERUM_SODIUM = coalesce(SERUM_SODIUM, INIT_SERUM_SODIUM), 
    DIALYSIS_PRIOR_WEEK = coalesce(DIALYSIS_PRIOR_WEEK, INIT_DIALYSIS_PRIOR_WEEK), 
    ASCITES = coalesce(ASCITES, INIT_ASCITES), 
    ENCEPH = coalesce(ENCEPH, INIT_ENCEPH), 
    BEGIN_INIT_DATE = coalesce(BEGIN_DATE, INIT_DATE), 
    # Set lower/upper bounds for MELD variables
    MELD_BILIRUBIN = ifelse(BILIRUBIN < 1, 1, BILIRUBIN), 
    MELD_SERUM_SODIUM = ifelse(SERUM_SODIUM > 137, 137, 
                               ifelse(SERUM_SODIUM < 125, 125, SERUM_SODIUM)), 
    MELD_INR = ifelse(INR < 1, 1, INR), 
    MELD_SERUM_CREAT_1 = ifelse(SERUM_CREAT > 4 | DIALYSIS_PRIOR_WEEK == "Y", 4, 
                              ifelse(SERUM_CREAT < 1, 1, SERUM_CREAT)), 
    MELD_SERUM_CREAT = ifelse(SERUM_CREAT > 3 | DIALYSIS_PRIOR_WEEK == "Y", 3, 
                              ifelse(SERUM_CREAT < 1, 1, SERUM_CREAT)), 
    MELD_ALBUMIN = ifelse(ALBUMIN > 3.5, 3.5, ifelse(ALBUMIN < 1.5, 1.5, ALBUMIN)), 
    # Define variables for cause of liver disease
    hepc = DGN_TCR == 4593, # Hepatitis C
    hepb = DGN_TCR == 4592, # Hepatitis B
    alcohol = DGN_TCR %in% c(4215, 4216, 4217), # Alcohol-related
    nash = DGN_TCR == 4214, # NASH
    hemochrom = DGN_TCR == 4302, # Hemochromatosis and others
    # TBS = Tumor Burden Score: the hypotenuse between lesion number and lesion 
    TBS = sqrt(TUMORNUM^2 + largesttumor^2), 
    # MELD 
    MELD = calc_meld(MELD_BILIRUBIN, MELD_INR, MELD_SERUM_CREAT_1), 
    # MELD-NA
    MELDNA = calc_meldna(MELD, MELD_SERUM_SODIUM), 
    # MELD 3.0
    MELD3 = calc_meld3(FEMALE, MELD_BILIRUBIN, MELD_SERUM_SODIUM, 
                       MELD_INR, MELD_SERUM_CREAT, MELD_ALBUMIN), 
    # Child-Pugh score
    Child_Pugh = calc_child_pugh(BILIRUBIN, INR, ALBUMIN, ASCITES, ENCEPH), 
    # Mehta score
    Mehta = calc_mehta(MELD3, Child_Pugh, AFP, TUMORNUM, TUMOR_SIZE1), 
    # HALT-HCC
    HALT_HCC = calc_halt_hcc(MELDNA, AFP, TBS), 
    # deMELD
    deMELD = calc_demeld(INIT_AGE, MELD, AFP, TUMORNUM, largesttumor,
                         hepb, alcohol, nash, hemochrom),
    # HCC-MELD
    HCC_MELD = calc_hcc_meld(MELD, AFP), 
    # MELD-Eq
    MELD_Eq = calc_meld_eq(MELD, AFP, TUMORNUM, largesttumor, wltime.y/30), 
    # ALBI
    ALBI = calc_albi(BILIRUBIN, ALBUMIN), 
    # REM_CD = reason for removal from the waiting list
    # 8 is death, 13 is dropout and 4/15/21 are transplanted
    removed_status = ifelse(REM_CD %in% c(8, 13), 1, 0), # Dead or dropped out
    transplanted_status = ifelse(REM_CD %in% c(4, 15, 21), 1, 0), 
    # INIT_DATE (part of exception data) = start date of lsting
    # END_DATE = earliest of dates of removal from waiting list, transplant, 
    # death, or time copy of data created
    fu_days = as.numeric(END_DATE - INIT_DATE), 
    # 90 days
    censored_90days = fu_days > 90, 
    removed_status_90days = ifelse(censored_90days == TRUE, 0, removed_status), 
    fu_days_90days = ifelse(censored_90days == TRUE, 90, fu_days), 
    # 6 months
    censored_6months = fu_days > 180, 
    removed_status_6months = ifelse(censored_6months == TRUE, 0, removed_status), 
    fu_days_6months = ifelse(censored_6months == TRUE, 180, fu_days), 
    # 1 year
    censored_1year = fu_days > 365, 
    removed_status_1year = ifelse(censored_1year == TRUE, 0, removed_status), 
    fu_days_1year = ifelse(censored_1year == TRUE, 365, fu_days)) %>% 
  drop_na(MELD3, AFP, tumortype)
```

### P-splines for log(AFP + 1)

We fit a GAM model to the 6-month outcome with spline terms for log(AFP + 1). 

```{r}
gam_fit = gam(fu_days_6months ~ MELD3 + s(log(AFP + 1)) + 
                T1 + single_tumor_2_3 + single_tumor_3_5, 
              data = df, family = "cox.ph", weights = removed_status_6months)

plot(gam_fit)
abline(v = c(1.5, 5.5))
```

Based on the spline exercise, we will bound AFP in our models by 1 and 250 Note that log(250 + 1) is 5.5, so it corresponds approximately to the cutoff of 6 in the above plot. 

```{r}
df = df %>% 
  mutate(AFP_trunc = ifelse(AFP > 250, 250, ifelse(AFP < 1, 1, AFP)))
```

### Train/test split

We split the data into 70% training and 30% test. 

```{r}
# Train-test split
set.seed(1)
idx = sample(nrow(df), 0.7*nrow(df))
train_df = df[idx,]
test_df = df[!(1:nrow(df) %in% idx),]

# Subset HCC cohort only
HCC_train_df = train_df %>% filter(HCC == TRUE)
HCC_test_df = test_df %>% filter(HCC == TRUE)

# Table summarizing counts
rbind(Overall = c(Total = nrow(df), 
                  Train = nrow(train_df), 
                  Test = nrow(test_df)), 
      HCC = c(Total = sum(df$HCC == TRUE), 
              Train = sum(train_df$HCC == TRUE), 
              Test = sum(test_df$HCC == TRUE)), 
      "Non-HCC" = c(Total = sum(df$HCC == FALSE), 
                    Train = sum(train_df$HCC == FALSE), 
                    Test = sum(test_df$HCC == FALSE)))
```

## Fit models to HCC patients

### Cox PH models

We train a Cox PH model to the 6-month outcome and 1) MELD 3.0 only; 2) the individual MELD components; and 3) MELD 3.0, log(AFP) (AFP restricted to be between 1 and 250), and tumor type. 

```{r}
# Model specifications to consider
model_specs = 
  c("MELD 3.0" = "MELD3",
    "MELD components" = "FEMALE + log(MELD_BILIRUBIN) + MELD_SERUM_SODIUM + log(MELD_INR) + log(MELD_SERUM_CREAT) + MELD_ALBUMIN", 
    "MELD 3.0 + log(AFP) + tumors" = "MELD3 + log(AFP_trunc) + tumortype")

# Cox PH models
fit_coxph_6months = lapply(model_specs, function(mod_form) {
  coxph(as.formula(paste("Surv(fu_days_6months, removed_status_6months) ~", mod_form)), 
        data = HCC_train_df, x = TRUE)
})
pred_coxph_6months = sapply(fit_coxph_6months, predict, newdata = HCC_test_df)
```

### Machine learning models

Fit random survival forest, gradient boosting, and two neural networks (DeepHit and DeepSurv) to the HCC patients. All MELD components, log(AFP), and tumor type are included as features. 

```{r, echo = FALSE}
load("rf.rData")
```

```{r}
# Random survival forest
# Categorical variables must be factors (defined in the data frame, not the 
# formula), not characters
# Factors are also very costly (?), causing R session to abort, so binary 
# variables should be coded as logical/numeric 0/1 when possible
HCC_train_df = 
  data.frame(HCC_train_df, 
             model.matrix(~., HCC_train_df[, "tumortype", drop = FALSE])[,-1])
HCC_test_df = 
  data.frame(HCC_test_df, 
             model.matrix(~., HCC_test_df[, "tumortype", drop = FALSE])[,-1])
```

```{r, eval = FALSE}
# 6 months
fit_rf_6months = rfsrc(
  Surv(fu_days_6months, removed_status_6months) ~ 
    FEMALE + log(MELD_BILIRUBIN) + BILIRUBIN + MELD_SERUM_SODIUM + SERUM_SODIUM + 
    log(MELD_INR) + INR + log(MELD_SERUM_CREAT) + SERUM_CREAT + 
    MELD_ALBUMIN + ALBUMIN + AFP + log(AFP_trunc) + 
    tumortypeT2.3.5 + tumortypemultifocal + tumortypeT3, 
  data = HCC_train_df)
pred_rf_6months = predict(fit_rf_6months, newdata = HCC_test_df)
vimp_rf_6months = vimp(fit_rf_6months, newdata = HCC_test_df)

save(fit_rf_6months, pred_rf_6months, vimp_rf_6months,
     file = "rf.rData")
```

```{r}
# Gradient boosting model
fit_gbm_6months = gbm(
  Surv(fu_days_6months, removed_status_6months) ~ 
    FEMALE + log(MELD_BILIRUBIN) + BILIRUBIN + MELD_SERUM_SODIUM + SERUM_SODIUM + 
    log(MELD_INR) + INR + log(MELD_SERUM_CREAT) + SERUM_CREAT + 
    MELD_ALBUMIN + ALBUMIN + AFP + log(AFP_trunc) + tumortype, 
  data = HCC_train_df %>% 
        mutate(FEMALE = as.factor(FEMALE), 
               tumortype = as.factor(tumortype)), 
      distribution = "coxph")
pred_gbm_6months = predict(fit_gbm_6months, newdata = HCC_test_df %>% 
                            mutate(FEMALE = as.factor(FEMALE), 
                                   tumortype = as.factor(tumortype)))
```

```{r}
# Deep learning
# pycox models to try
pycox_mods = c(
  # Based on the PMF of a discrete Cox model
  "deephit" = deephit, 
  # Based on the partial likelihood from a Cox PH
  "deepsurv" = deepsurv)

# Fit all pycox models with default parameters
set_seed(1)
fit_pycox_6months = lapply(pycox_mods, function(fun) {
  fun(Surv(fu_days_6months, removed_status_6months) ~ ., 
      data = HCC_train_df %>% 
        mutate(
          FEMALE = as.factor(FEMALE), 
          log_MELD_BILIRUBIN = log(MELD_BILIRUBIN), 
          log_MELD_INR = log(MELD_INR), 
          log_MELD_SERUM_CREAT = log(MELD_SERUM_CREAT), 
          log_AFP_trunc = log(AFP_trunc), 
          tumortype = as.factor(tumortype), 
        )  %>% 
        dplyr::select(fu_days_6months, removed_status_6months, FEMALE, 
                      log_MELD_BILIRUBIN, BILIRUBIN, 
                      MELD_SERUM_SODIUM, SERUM_SODIUM, 
                      log_MELD_INR, INR, 
                      log_MELD_SERUM_CREAT, SERUM_CREAT, 
                      MELD_ALBUMIN, ALBUMIN,  
                      log_AFP_trunc, AFP, tumortype))
})
# Predict on data sets
preds_pycox_6months = sapply(fit_pycox_6months, function(fit) {
  predict(fit, 
          newdata = HCC_test_df %>% 
            mutate(
              FEMALE = as.factor(FEMALE), 
              log_MELD_BILIRUBIN = log(MELD_BILIRUBIN), 
              log_MELD_INR = log(MELD_INR), 
              log_MELD_SERUM_CREAT = log(MELD_SERUM_CREAT), 
              log_AFP_trunc = log(AFP_trunc), 
              tumortype = as.factor(tumortype), 
            )  %>% 
            dplyr::select(fu_days_6months, removed_status_6months, FEMALE, 
                          log_MELD_BILIRUBIN, BILIRUBIN, 
                          MELD_SERUM_SODIUM, SERUM_SODIUM, 
                          log_MELD_INR, INR, 
                          log_MELD_SERUM_CREAT, SERUM_CREAT, 
                          MELD_ALBUMIN, ALBUMIN,  
                          log_AFP_trunc, AFP, tumortype), 
          type = "survival")[,"180"]
})
```

### Coefficients and variable importance

When considering Cox models fit to MELD 3.0, log(AFP) (AFP restricted to be between 1 and 250), and the tumor variables, the coefficients for MELD and AFP are consistently significant. At least some of the tumor variable coefficients are significant for each outcome. 

```{r}
# Model of interest
my_model = "MELD 3.0 + log(AFP) + tumors"

# Coefficient summary
summary(fit_coxph_6months[[my_model]])
```

Univariate HRs for each of the covariates in the final Cox PH models (MELD 3.0, log(AFP), and tumors). 

```{r}
# Covariates
my_covars = c("MELD3", "log(AFP_trunc)", "tumortype")

# Univariate Cox PH models
fit_coxph_univariate_6months = lapply(my_covars, function(my_covar) {
  coxph(as.formula(paste("Surv(fu_days_6months, removed_status_6months) ~", my_covar)), 
        data = HCC_train_df, x = TRUE)
})
do.call(
  rbind, 
  lapply(fit_coxph_univariate_6months, function(x) {
    cbind(summary(x)$coefficients, 
          as.data.frame(exp(confint(x))) %>% rename_with(~paste("exp(coef)", .x)))
  })
)
```

Variable importance for random forest model. The MELD components (except for `female`) score high, but so do AFP and some of the tumor variables. 

```{r, fig.width = 12}
# Wrapper that replaces variable names in VI plot with prettier labels
pretty_plot.rfsrc = function(rfsrc_vi) {
  rf_var_dict = c("FEMALE" = "Female", 
                  "MELD_BILIRUBIN" = "Bilirubin (MELD 3.0)", 
                  "BILIRUBIN" = "Bilirubin", 
                  "MELD_SERUM_SODIUM" = "Serum sodium (MELD 3.0)", 
                  "SERUM_SODIUM" = "Serum sodium", 
                  "MELD_INR" = "INR (MELD 3.0)", 
                  "INR" = "INR", 
                  "MELD_SERUM_CREAT" = "Serum creatinine (MELD 3.0)", 
                  "SERUM_CREAT" = "Serum creatinine", 
                  "MELD_ALBUMIN" = "Albumin (MELD 3.0)", 
                  "ALBUMIN" = "Albumin", 
                  "AFP" = "AFP", 
                  "AFP_trunc" = "log(truncated AFP)", 
                  "tumortypeT2.3.5" = "Tumor type: T2 3-5", 
                  "tumortypemultifocal" = "Tumor type: multifocal",
                  "tumortypeT3" = "Tumor type: T3")
  names(rfsrc_vi$importance)[
    match(names(rfsrc_vi$importance), names(rf_var_dict))] = rf_var_dict
  plot(rfsrc_vi)
}

pretty_plot.rfsrc(vimp_rf_6months)
```

## Concordance, integrated Brier scores, and calibration

We use a bootstrap routine to obtain 95% confidence intervals for each 6-month model's test concordance and integrated Brier score (when applicable).  

```{r}
# All other scores, applied to test set
scores_test = HCC_test_df %>% 
  dplyr::select(Mehta, HALT_HCC, deMELD, HCC_MELD, MELD_Eq, ALBI)
```

```{r, echo = FALSE}
load("boot_diagnostics.rData")
```

```{r, eval = FALSE}
# Number of bootstraps
B = 1000

# Not sure how to prevent it (the options at the top of notebook don't fix it), 
# but running in parallel appears to cause memory overflow issues, leading to 
# R and/or the entire computer crashing
# So currently running in serial. Takes about 9.5 hours
# For some reason, you need to run this line-by-line using Command + Enter
# Running chunk by clicking the little green arrow or copy-pasting to the 
# terminal seems to cause it to hang
boot_diagnostics = foreach::foreach(
  b = 1:B, .packages = c("tidyverse", "survival", "randomForestSRC", "gbm", 
                         "survivalmodels", "pec")
  ) %do% {
  # Set seed
  set.seed(b)
  # Create bootstrap sample of test set
  boot_idx = sample(nrow(HCC_test_df), replace= TRUE)
  boot_test_df = HCC_test_df[boot_idx,]
  
  # Cox PH models
  boot_pred_coxph_6months = sapply(fit_coxph_6months, predict, newdata = boot_test_df)
  
  # Random survival forest
  boot_pred_rf_6months =
    predict(fit_rf_6months, newdata = boot_test_df)
  
  # Gradient boosting model
  boot_pred_gbm_6months = predict(fit_gbm_6months, newdata = boot_test_df %>% 
                                    mutate(FEMALE = as.factor(FEMALE), 
                                           tumortype = as.factor(tumortype)))

  # Deep learning
  boot_preds_pycox_6months = sapply(fit_pycox_6months, function(fit) {
    predict(fit, 
            newdata = boot_test_df %>% 
              mutate(
                FEMALE = as.factor(FEMALE), 
                log_MELD_BILIRUBIN = log(MELD_BILIRUBIN), 
                log_MELD_INR = log(MELD_INR), 
                log_MELD_SERUM_CREAT = log(MELD_SERUM_CREAT), 
                log_AFP_trunc = log(AFP_trunc), 
                tumortype = as.factor(tumortype), 
              )  %>% 
              dplyr::select(fu_days_6months, removed_status_6months, FEMALE, 
                            log_MELD_BILIRUBIN, BILIRUBIN, 
                            MELD_SERUM_SODIUM, SERUM_SODIUM, 
                            log_MELD_INR, INR, 
                            log_MELD_SERUM_CREAT, SERUM_CREAT, 
                            MELD_ALBUMIN, ALBUMIN,  
                            log_AFP_trunc, AFP, tumortype), 
            type = "survival")[,"180"]
  })
  
  # All other scores, applied to test set
  boot_scores_test = boot_test_df %>% 
    dplyr::select(Mehta, HALT_HCC, deMELD, HCC_MELD, MELD_Eq, ALBI)
  
  # Concordance for each outcome
  concordance_df = data.frame(
    apply(cbind(boot_pred_coxph_6months, 
                "Random survival forest" = boot_pred_rf_6months$predicted, 
                "Gradient boosting model" = boot_pred_gbm_6months, 
                data.frame(1 - boot_preds_pycox_6months) %>% 
                  setNames(c("DeepHit", "DeepSurv")), 
                boot_scores_test), 2, function(pred) {
      if(all(is.na(pred))) {
        return(NA)
      }
      concordance(Surv(fu_days_90days, removed_status_90days) ~ pred, 
                  data.frame(pred = pred,
                             boot_test_df %>% 
                               dplyr::select(fu_days_90days, 
                                             removed_status_90days)), 
                reverse = TRUE)$concordance
      }), 
    apply(cbind(boot_pred_coxph_6months, 
                "Random survival forest" = boot_pred_rf_6months$predicted, 
                "Gradient boosting model" = boot_pred_gbm_6months, 
                data.frame(1 - boot_preds_pycox_6months) %>% 
                  setNames(c("DeepHit", "DeepSurv")), 
                boot_scores_test), 2, function(pred) {
      if(all(is.na(pred))) {
        return(NA)
      }
      concordance(Surv(fu_days_6months, removed_status_6months) ~ pred, 
                  data.frame(pred = pred,
                             boot_test_df %>% 
                               dplyr::select(fu_days_6months, 
                                             removed_status_6months)), 
                reverse = TRUE)$concordance
      }), 
    apply(cbind(boot_pred_coxph_6months, 
                "Random survival forest" = boot_pred_rf_6months$predicted, 
                "Gradient boosting model" = boot_pred_gbm_6months, 
                data.frame(1 - boot_preds_pycox_6months) %>% 
                  setNames(c("DeepHit", "DeepSurv")), 
                boot_scores_test), 2, function(pred) {
      if(all(is.na(pred))) {
        return(NA)
      }
      concordance(Surv(fu_days_1year, removed_status_1year) ~ pred, 
                  data.frame(pred = pred,
                             boot_test_df %>% 
                               dplyr::select(fu_days_1year, 
                                             removed_status_1year)), 
                reverse = TRUE)$concordance
      })) %>% setNames(c("90 days", "6 months", "1 year"))
  
  # Integrated Brier score for 6 months only
  brier_df = data.frame(as.matrix(
    crps(pec(object = c(fit_coxph_6months, 
                        list("Random survival forest" = fit_rf_6months)), 
             formula = Surv(fu_days_6months, removed_status_6months) ~ 1, 
             data = boot_test_df))[-1,]
    )) %>% 
    setNames("6 months")
  
  return(list(concordance_df = concordance_df, 
              brier_df = brier_df))
}

save(boot_diagnostics, file = "boot_diagnostics.rData")
```

We report the test concordance for each model with a 95% bootstrap CI, evaluated for each of the 3 outcomes: 90 days, 6 months, and 1 year. 

```{r}
# Point estimates for concordance
concordance_est = data.frame(
  apply(cbind(pred_coxph_6months, 
              "Random survival forest" = pred_rf_6months$predicted, 
              "Gradient boosting model" = pred_gbm_6months, 
              data.frame(1 - preds_pycox_6months) %>% 
                setNames(c("DeepHit", "DeepSurv")), 
              scores_test), 2, function(pred) {
    concordance(Surv(fu_days_90days, removed_status_90days) ~ pred, 
                data.frame(pred = pred,
                           HCC_test_df %>% 
                             dplyr::select(fu_days_90days, 
                                           removed_status_90days)), 
                reverse = TRUE)$concordance
    }), 
  apply(cbind(pred_coxph_6months, 
              "Random survival forest" = pred_rf_6months$predicted, 
              "Gradient boosting model" = pred_gbm_6months, 
              data.frame(1 - preds_pycox_6months) %>% 
                setNames(c("DeepHit", "DeepSurv")), 
              scores_test), 2, function(pred) {
    concordance(Surv(fu_days_6months, removed_status_6months) ~ pred, 
                data.frame(pred = pred,
                           HCC_test_df %>% 
                             dplyr::select(fu_days_6months, 
                                           removed_status_6months)), 
                reverse = TRUE)$concordance
    }), 
  apply(cbind(pred_coxph_6months, 
              "Random survival forest" = pred_rf_6months$predicted, 
              "Gradient boosting model" = pred_gbm_6months, 
              data.frame(1 - preds_pycox_6months) %>% 
                setNames(c("DeepHit", "DeepSurv")), 
              scores_test), 2, function(pred) {
    concordance(Surv(fu_days_1year, removed_status_1year) ~ pred, 
                data.frame(pred = pred,
                           HCC_test_df %>% 
                             dplyr::select(fu_days_1year, 
                                           removed_status_1year)), 
                reverse = TRUE)$concordance
    })) %>% setNames(c("90 days", "6 months", "1 year"))

# Concordance 2.5%
concordance_lo = as.data.frame(
  apply(abind(lapply(boot_diagnostics, function(x){x$concordance_df}), 
              along = 3), c(1,2), quantile, 
        0.025, na.rm = TRUE))
# Concordance 97.5%
concordance_hi = as.data.frame(
  apply(abind(lapply(boot_diagnostics, function(x){x$concordance_df}), 
              along = 3), c(1,2), quantile, 
        0.975, na.rm = TRUE))

# Table of concordance statistics with 95% CI
concordance_tab = data.frame(
  paste0(round(concordance_est$`90 days`, 3), " (", 
         round(concordance_lo$`90 days`, 3), ", " ,
         round(concordance_hi$`90 days`, 3), ")"), 
  paste0(round(concordance_est$`6 months`, 3), " (", 
         round(concordance_lo$`6 months`, 3), ", " ,
         round(concordance_hi$`6 months`, 3), ")"), 
  paste0(round(concordance_est$`1 year`, 3), " (", 
         round(concordance_lo$`1 year`, 3), ", " ,
         round(concordance_hi$`1 year`, 3), ")")
) %>% setNames(c("90 days", "6 months", "1 year")) %>% 
  `rownames<-`(rownames(concordance_est))
concordance_tab
```

p-values for significant difference in C-statistics between the proposed 6-month model that incorporates AFP and tumor type and 1) MELD 3.0, 2) the best-performing 6-month machine learning model (gradient boosting), and 3) each of the previously-proposed approaches. All p-values reported have been adjusted using the Holm correction. 

```{r}
# Compare 6-month model to MELD 3.0, best-performing ML model (GBM), 
# and to all previous scores
pvals_6months = sapply(data.frame(
  pred_coxph_6months[,1:2], 
  "Random survival forest" = pred_rf_6months$predicted, 
  "Gradient boosting model" = pred_gbm_6months, 
  data.frame(1 - preds_pycox_6months) %>% 
    setNames(c("DeepHit", "DeepSurv")), 
  scores_test), function(pred) {
  compareC(HCC_test_df$fu_days_6months, 
           HCC_test_df$removed_status_6months, 
           pred_coxph_6months[,"MELD 3.0 + log(AFP) + tumors"], 
           pred)$pval
})

# Adjust all p-values (Holm's adjustment)
pvals_adj = p.adjust(pvals_6months)
data.frame(concordance_tab[c("MELD 3.0 + log(AFP) + tumors", 
                             "MELD 3.0", 
                             "MELD components", 
                             "Random survival forest", 
                             "Gradient boosting model", 
                             "DeepHit", 
                             "DeepSurv", 
                             names(scores_test)), "6 months", drop = FALSE], 
           c("", round(pvals_adj[names(pvals_6months)], 4))) %>% 
  setNames(c("C-statistic (95% CI)", "Adjusted p-value"))
```

We report the test integrated Brier score for each model with a 95% bootstrap CI, evaluated for the 6-month outcome only. 

```{r}
# Point estimates for integrated Brier score
brier_est = data.frame(as.matrix(
  crps(pec(object = c(fit_coxph_6months, 
                      list("Random survival forest" = fit_rf_6months)), 
           formula = Surv(fu_days_6months, removed_status_6months) ~ 1, 
           data = HCC_test_df))[-1,]
)) %>% 
  setNames("6 months")

# Brier score 2.5%
brier_lo = as.data.frame(
  apply(abind(lapply(boot_diagnostics, function(x){x$brier_df}), 
              along = 3), c(1,2), quantile, 
        0.025, na.rm = TRUE))
# Brier score 97.5%
brier_hi = as.data.frame(
  apply(abind(lapply(boot_diagnostics, function(x){x$brier_df}), 
              along = 3), c(1,2), quantile, 
        0.975, na.rm = TRUE))

# Table of Brier scores with 95% CI
brier_tab = data.frame(
  paste0(round(brier_est$`6 months`, 3), " (", 
         round(brier_lo$`6 months`, 3), ", " ,
         round(brier_hi$`6 months`, 3), ")")
) %>% setNames("6 months") %>% 
  `rownames<-`(rownames(brier_est))
brier_tab
```

We plot the 6-month survival probabilities against MELD 3.0. Shown below are the plots for the proposed Cox PH model that incorporates MELD 3.0, log(AFP) (AFP restricted to be between 1 and 250), and tumor type. Points are colored based on whether the patient was actually removed from the waitlist by 6 months. Spearman's correlation is reported in the top right corner. 

```{r}
# Model of interest
my_model = "MELD 3.0 + log(AFP) + tumors"
# Get survival probabilities at 6 months
surv_coxph_6months = t(summary(survfit(fit_coxph_6months[[my_model]], 
                                 newdata = HCC_test_df), times = 180)$surv)

# Plot survival probabilities against MELD 3.0
data.frame(MELD3 = HCC_test_df$MELD3, 
           surv = surv_coxph_6months, 
           removed = factor(HCC_test_df$removed_status_6months, 
                            levels = c(1, 0), labels = c("Yes", "No"))) %>% 
  ggplot(aes(x = MELD3, y = surv)) + 
  geom_point(aes(color = removed), alpha = 0.5) + 
  geom_smooth(color = "black") + 
  geom_label(data = data.frame(Cor = c(cor(HCC_test_df$MELD3, 
                                           surv_coxph_6months, 
                                           method = "spearman"))), 
             aes(label = round(Cor, 2)), color = "black", 
             x = Inf, y = Inf, vjust = 1.3, hjust = "inward", 
             alpha = 0.8, size = 3) + 
  scale_color_manual(name = "Removed", values = c("firebrick3", "grey30")) + 
  xlab("MELD 3.0") + ylab("Predicted survival probability")
```

We bin the MELD 3.0 scores into 4 groups (6-10, 11-15, 16-20, and 20+) and plot the distribution of predicted survival probabilities for each group. 

```{r}
data.frame(breaks = cut(HCC_test_df$MELD3, breaks = c(6, 11, 16, 20, Inf), 
                        include.lowest = TRUE), 
           surv = surv_coxph_6months) %>% 
  ggplot(aes(x = breaks, y = surv)) + 
  geom_boxplot() + 
  xlab("MELD 3.0 ranges") + ylab("Predicted survival probability")
```

Calibration plot for the proposed model: the test set is divided into quartiles based on the. 6-month survival probability. The lines represent the Kaplan-Meier curves for these quartiles, with confidence intervals shaded. The points are averaged over all predicted survival probabilities for individuals in the quartile, at a given time point. Asymptotic error bars for the averaged predictions are shown on the right-hand panel, but the two side-by-side plots are otherwise the same. 

```{r}
# Model of interest
my_model = "MELD 3.0 + log(AFP) + tumors"
# Number of survival probability bins
n_timepoints = 10

# Get test survival probabilities for 6-month model
surv_6months_mat = summary(survfit(fit_coxph_6months[[my_model]], newdata = HCC_test_df), 
                          times = seq(0, 180, length = n_timepoints))$surv
# Divide test set into quartiles based on probability at 6 months 
quart_thresh_6months = quantile(surv_6months_mat[nrow(surv_6months_mat),], 
                                seq(0.25, 0.75, by = 0.25))
quart_6months = rev(1:(length(quart_thresh_6months)+1))[
  as.numeric(cut(surv_6months_mat[nrow(surv_6months_mat),], 
                 breaks = c(-Inf, as.numeric(quart_thresh_6months), Inf)))]

# Data frame for plotting calibration
calib_6months_df = data.frame(
  Quartile = factor(rep(4:1, each = n_timepoints)), 
  time = rep(seq(0, 180, length = n_timepoints), times = 4), 
  surv = as.vector(sapply(4:1, function(i) {
    rowMeans(surv_6months_mat[,quart_6months == i])
  })), 
  surv_se = as.vector(sapply(4:1, function(i) {
    apply(surv_6months_mat[,quart_6months == i], 1, sd)
  })))

# Kaplan-Meier plot
p_km_6months = ggsurvplot(survfit(Surv(fu_days_6months, removed_status_6months) ~ 
                                    quart_6months, data = HCC_test_df), 
                          legend.title = "", 
                          legend.labs = paste("Quartile", 1:4),
                          censor = FALSE, conf.int = TRUE) 

# KM plot with predicted survival probabilities for each quartile
p1 = p_km_6months$plot +
  geom_point(
    data = calib_6months_df, 
    aes(x = time, y = surv, 
        color = Quartile)) + 
  scale_color_manual(values = rep(scales::hue_pal()(4), 2)) + 
  coord_cartesian(ylim = c(0.65, 1)) + 
  guides(color = "none", fill = guide_legend(override.aes = list(alpha = 1), nrow = 2)) + 
  theme(legend.position = "bottom")

# Also include asymptotic CIs for predicted survival probabilities
p2 = p_km_6months$plot +
  geom_pointrange(
    data = calib_6months_df, 
    aes(x = time, y = surv, 
        ymin = surv - 1.96*surv_se, 
        ymax = surv + 1.96*surv_se, 
        color = Quartile), size = 0.25) + 
  scale_color_manual(values = rep(scales::hue_pal()(4), 2)) + 
  ylim(0, 1.2) + 
  coord_cartesian(ylim = c(0.4, 1)) + 
  guides(color = "none", fill = guide_legend(override.aes = list(alpha = 1), nrow = 2)) + 
  theme(legend.position = "bottom")

# Display plots
grid.arrange(p1, p2, ncol = 2)
```

## Re-fit MELD 3.0

Re-fit the MELD 3.0 model to recover the baseline hazard/predict new observations on the probability scale. 

```{r}
# MELD cohort
MELD_dir = "/Users/jliang/Library/CloudStorage/Box-Box/MELD\ QSU/data/"
MELD_train_df = read.csv(paste0(MELD_dir, "MELD3_Dev_Cohort.csv"))

# Re-fit MELD and sanity check that the coefficients look correct
my_MELD_train_df = MELD_train_df %>% 
  mutate(
    FEMALE = GENDER == "F", 
    # Set lower/upper bounds for MELD variables
    MELD_BILIRUBIN = ifelse(INIT_BILIRUBIN < 1, 1, INIT_BILIRUBIN), 
    MELD_SERUM_SODIUM = 137 - ifelse(INIT_SERUM_SODIUM > 137, 137, 
                               ifelse(INIT_SERUM_SODIUM < 125, 125, INIT_SERUM_SODIUM)), 
    MELD_INR = ifelse(INIT_INR < 1, 1, INIT_INR), 
    MELD_SERUM_CREAT = ifelse(INIT_SERUM_CREAT > 3 | INIT_DIALYSIS_PRIOR_WEEK == "Y", 3, 
                              ifelse(INIT_SERUM_CREAT < 1, 1, INIT_SERUM_CREAT)), 
    MELD_ALBUMIN = 3.5 - ifelse(INIT_ALBUMIN > 3.5, 3.5, 
                                ifelse(INIT_ALBUMIN < 1.5, 1.5, INIT_ALBUMIN)), 
  )
MELD_fit = coxph(Surv(SurvTime_by90d, Death_by90d) ~ 
                   FEMALE + log(MELD_BILIRUBIN) * MELD_SERUM_SODIUM + 
                   log(MELD_INR) + log(MELD_SERUM_CREAT) * MELD_ALBUMIN, 
                 data = my_MELD_train_df, x = TRUE)
summary(MELD_fit)
```

Plot the survival probabilities from the proposed model that also incorporates AFP and tumor type against the survival probabilities for MELD 3.0. 

```{r}
# Model of interest
my_model = "MELD 3.0 + log(AFP) + tumors"
surv_MELD =  t(summary(survfit(MELD_fit, newdata = HCC_test_df %>% 
                              mutate(MELD_SERUM_SODIUM = 137 - MELD_SERUM_SODIUM, 
                                     MELD_ALBUMIN = 3.5 - MELD_ALBUMIN)),
                                   times = 90)$surv)

# Plot survival probabilities against MELD 3.0
data.frame(MELD3 = surv_MELD, 
           surv = surv_coxph_6months, 
           removed = factor(HCC_test_df$removed_status_6months, 
                            levels = c(1, 0), labels = c("Yes", "No"))) %>% 
  ggplot(aes(x = MELD3, y = surv)) + 
  geom_point(aes(color = removed), alpha = 0.5) + 
  geom_smooth(color = "black") + 
  geom_label(data = data.frame(Cor = cor(surv_MELD, 
                                         surv_coxph_6months, 
                                         method = "spearman")), 
             aes(label = round(Cor, 2)), color = "black", 
             x = -Inf, y = Inf, vjust = 1.3, hjust = -0.3, 
             alpha = 0.8, size = 3) + 
  scale_color_manual(name = "Removed", values = c("firebrick3", "grey30")) + 
  xlab("MELD 3.0 90-day survival") + 
  ylab("Proposed model survival")
```

## Rescale to MELD

After we select the best 6-month model, we rescale the results to MELD. To do this, fit a model to the 90-day outcome based on all patients in the training set, with an interaction between non-HCC patients and MELD 3.0, a main effect for HCC status, and an interaction between HCC and the linear predictor from the chosen 6-month model. In other words, the predictions for non-HCC patients are based on only MELD 3.0, and the predictions for HCC patients are based on only the 6-month linear predictor (and HCC status). We then regress the MELD 3.0 scores against the linear predictor from this fit for non-HCC patients in the test set. 

```{r}
# Add linear predictor for 6-month model to train and test sets (non-HCC and HCC)
train_df$preds6months = 0
train_df$preds6months[train_df$HCC == TRUE] = 
  as.vector(predict(fit_coxph_6months[[my_model]], newdata = HCC_train_df))
test_df$preds6months = 0
test_df$preds6months[test_df$HCC == TRUE] = 
  as.vector(predict(fit_coxph_6months[[my_model]], newdata = HCC_test_df))

# Add variable that is an interaction between non-HCC and MELD3
# i.e. MELD3 for non-HCC and 0 for HCC
train_df = train_df %>% 
  mutate(nonHCC_MELD = (1-HCC)* MELD3)
test_df = test_df %>% 
  mutate(nonHCC_MELD = (1-HCC)* MELD3)

# Refit model to both HCC and non-HCC patients
fit_coxph_HCC_nonHCC_6months = coxph(
  Surv(fu_days_90days, removed_status_90days) ~ 
        nonHCC_MELD + HCC + HCC:preds6months, 
  data = train_df, x = TRUE)

# Add linear predictor from fit to test data
test_df = test_df %>% 
  mutate(linpred_6months = predict(fit_coxph_HCC_nonHCC_6months, 
                                   newdata = test_df, type = "lp"))

# Regress MELD 3.0 against linear predictor for non-HCC patients
# Add predictions from fit to test data
fit_MELD3_lp_6months= lm(MELD3 ~ linpred_6months, 
                         data = test_df %>% filter(HCC == FALSE))
test_df = test_df %>% 
  mutate(Proposed_6months = predict(fit_MELD3_lp_6months, newdata = test_df),      
         diff_6months = Proposed_6months - MELD3, 
         Cohort = ifelse(HCC == TRUE, "HCC", "Non-HCC"))

# Scatterplot of MELD 3.0 vs. linear predictor for non-HCC and HCC patients
test_df %>% 
  ggplot(aes(x = linpred_6months, y = MELD3, color = Cohort)) + 
  geom_point(alpha = 0.5) + geom_smooth(method = "lm") +
  xlab("Linear predictor") + ylab("MELD 3.0") + 
  # geom_smooth legend background is grey; set manually to transparent
  guides(color = guide_legend(override.aes = list(fill = NA))) 
```

Mean number of points to add for each MELD 3.0 score. Error bars indicate +/- 1 standard deviation. 

```{r}
# Mean number of points to add for each 
rbind(test_df %>% mutate(Cohort = "All"), 
      test_df) %>% 
  mutate(MELD3 = droplevels(fct_collapse(factor(MELD3), 
                                         "40+" = as.character(40:100)))) %>% 
  group_by(MELD3, Cohort) %>% 
  summarize(diff = mean(diff_6months, na.rm = T)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = Cohort, values_from = diff) %>% 
  print(n = 100)

# Scatterplot of points to add against MELD
p1 = test_df %>% 
  mutate(MELD3 = ifelse(MELD3 > 40, 40, MELD3)) %>% 
  group_by(MELD3, Cohort) %>% 
  summarize(mu = mean(diff_6months, na.rm = T), 
            sd = sd(diff_6months, na.rm = T)) %>% 
  ungroup() %>% 
  ggplot(aes(x = MELD3, y = mu, color = Cohort)) + 
  geom_point(position = position_dodge(0.1)) + 
  geom_errorbar(aes(ymin=mu-sd, ymax=mu+sd), width = 0,
                 position = position_dodge(0.1)) + 
  scale_x_continuous(breaks = seq(0, 40, by = 5), limits = c(5, 40)) +
  ylim(-8, 8) +
  geom_vline(xintercept = 17.5, color = "grey") +
  # geom_vline(xintercept = c(6, 10, 20, 40), color = "grey") +
  xlab("MELD 3.0") + ylab("Average number of points to add")
# Marginal histogram
p2 = test_df %>% 
  mutate(MELD3 = ifelse(MELD3 > 40, 40, MELD3)) %>% 
  ggplot(aes(x = MELD3, fill = Cohort)) +
  geom_histogram(color = "black", alpha = 0.6, position = "identity", bins = 35) + 
  theme_void() +
  theme(legend.position = "none", 
        plot.margin = unit(c(3, 29, 0, 9), "mm"))
grid.arrange(p2, p1, nrow = 2, ncol = 1, widths = 7, heights = c(1, 7))
```

This plot groups together MELD scores with bins <10 people. The bins are 29-30, 31-33, and 34+. 

```{r}
# Scatterplot of points to add against MELD
p1 = test_df %>% 
  mutate(MELD3 = case_when(
    MELD3 %in% 29:30 ~ 29, 
    MELD3 %in% 31:33 ~ 31, 
    MELD3 > 34 ~ 34, 
    TRUE ~ MELD3
  )) %>% 
  group_by(MELD3, Cohort) %>% 
  summarize(mu = mean(diff_6months, na.rm = T), 
            sd = sd(diff_6months, na.rm = T)) %>% 
  ungroup() %>% 
  ggplot(aes(x = MELD3, y = mu, color = Cohort)) + 
  geom_point(position = position_dodge(0.1)) + 
  geom_errorbar(aes(ymin=mu-sd, ymax=mu+sd), width = 0,
                 position = position_dodge(0.1)) + 
  scale_x_continuous(breaks = seq(0, 40, by = 5), limits = c(5, 40)) +
  ylim(-8, 8) + 
  geom_vline(xintercept = 17.5, color = "grey") +
  # geom_vline(xintercept = c(6, 10, 20, 40), color = "grey") +
  xlab("MELD 3.0") + ylab("Average number of points to add")
grid.arrange(p2, p1, nrow = 2, ncol = 1, widths = 7, heights = c(1, 7))
```

This plot uses +/- 1 standard error (i.e. the sample standard deviation, which divides by the square root of the sample size) for the error bars. 

```{r}
# Scatterplot of points to add against MELD
p1 = test_df %>% 
  mutate(MELD3 = case_when(
    MELD3 %in% 29:30 ~ 29, 
    MELD3 %in% 31:33 ~ 31, 
    MELD3 > 34 ~ 34, 
    TRUE ~ MELD3
  )) %>% 
  group_by(MELD3, Cohort) %>% 
  summarize(mu = mean(diff_6months, na.rm = T), 
            sd = sd(diff_6months, na.rm = T), 
            n = n(), 
            se = sd/sqrt(n)) %>% 
  ungroup() %>% 
  ggplot(aes(x = MELD3, y = mu, color = Cohort)) + 
  geom_point(position = position_dodge(0.1)) + 
  geom_errorbar(aes(ymin=mu-se, ymax=mu+se), width = 0,
                 position = position_dodge(0.1)) + 
  scale_x_continuous(breaks = seq(0, 40, by = 5), limits = c(5, 40)) +
  ylim(-8, 8) +
  geom_vline(xintercept = 17.5, color = "grey") +
  # geom_vline(xintercept = c(6, 10, 20, 40), color = "grey") +
  xlab("MELD 3.0") + ylab("Average number of points to add")
grid.arrange(p2, p1, nrow = 2, ncol = 1, widths = 7, heights = c(1, 7))
```

This plot shows the median and IQR instead of the mean and standard deviation/error. 

```{r}
# Scatterplot of points to add against MELD
p1 = test_df %>% 
  mutate(MELD3 = case_when(
    MELD3 %in% 29:30 ~ 29, 
    MELD3 %in% 31:33 ~ 31, 
    MELD3 > 34 ~ 34, 
    TRUE ~ MELD3
  )) %>% 
  group_by(MELD3, Cohort) %>% 
  summarize(median = median(diff_6months, na.rm = T), 
            q1 = quantile(diff_6months, probs = 0.25, na.rm = T), 
            q3 = quantile(diff_6months, probs = 0.75, na.rm = T)) %>% 
  ungroup() %>% 
  ggplot(aes(x = MELD3, y = median, color = Cohort)) + 
  geom_point(position = position_dodge(0.1)) + 
  geom_errorbar(aes(ymin=q1, ymax=q3), width = 0,
                 position = position_dodge(0.1)) + 
  scale_x_continuous(breaks = seq(0, 40, by = 5), limits = c(5, 40)) +
  ylim(-8, 8) + 
  geom_vline(xintercept = 17.5, color = "grey") +
  # geom_vline(xintercept = c(6, 10, 20, 40), color = "grey") +
  xlab("MELD 3.0") + ylab("Median number of points to add")
grid.arrange(p2, p1, nrow = 2, ncol = 1, widths = 7, heights = c(1, 7))
```

Histogram of proposed score among HCC patients, shaded by risk quartile. 

```{r}
test_df %>% 
  filter(HCC == TRUE) %>% 
  mutate(quant = cut(Proposed_6months, breaks = quantile(Proposed_6months))) %>% 
  drop_na(quant) %>% 
  ggplot(aes(x = Proposed_6months, fill = factor(quant, levels = levels(quant)))) + 
  geom_histogram(color = "black") + 
  scale_fill_discrete(name = NULL, labels = paste("Quartile", 1:4)) + 
  xlab("Proposed score") + ylab("Count") + 
  theme(legend.position = "bottom")
```

### Formula for HCC patients, aligned with MELD

This is the risk prediction formula for HCC patients, re-scaled to be aligned with MELD: 

```{r}
# Coefficients from fitting MELD 3.0 against linear predictor 
lp_intercept_6months = coef(fit_MELD3_lp_6months)["(Intercept)"]
lp_slope_6months = coef(fit_MELD3_lp_6months)[("linpred_6months")]

# coxph function centers variables, so this is the linear shift to subtract 
# off of the linear predictor
my_shift_6months = sum(coef(fit_coxph_HCC_nonHCC_6months) * 
                         fit_coxph_HCC_nonHCC_6months$means)

# Cox PH coefficient to rescale 6-month linear predictor
coxph_slope = coef(fit_coxph_HCC_nonHCC_6months)["HCC:preds6months"]
# Shift for the second Cox PH model (fit to the linear predictor)
coxph_shift = sum(coef(fit_coxph_6months[[my_model]]) * 
                    fit_coxph_6months[[my_model]]$means)

# Intercept for HCC patients
my_intercept_6months = lp_intercept_6months + lp_slope_6months * 
  (coef(fit_coxph_HCC_nonHCC_6months)["HCC"] - my_shift_6months - 
     coxph_slope * coxph_shift)
# Coefficients for HCC patients
my_coefs_6months = lp_slope_6months * coxph_slope *
  coef(fit_coxph_6months[[my_model]])
names(my_coefs_6months) = c("MELD3", "log(AFP)", "[T2 3-5]", "[multifocal]", "[T3]")

# Final formula
paste(c(round(my_intercept_6months, 3), sapply(names(my_coefs_6months), function(x) {
  paste0(round(my_coefs_6months[x], 3), "*", x)
})), collapse = " + ")
```

We predict the 90-day survival probability for HCC patients using the proposed 6-month score. Then, we predict their survival probability using only their MELD score, treating them as though they are non-HCC patients. The difference between these survival probabilities is essentially 0 and the points line up perfectly. 

```{r}
# Add variable that is an interaction between HCC and and the proposed score
# i.e. the proposed score for HCC and 0 for non-HCC
train_df = train_df %>% 
  mutate(HCC_preds6months = HCC* preds6months)
test_df = test_df %>% 
  mutate(HCC_preds6months = HCC* preds6months)

# Refit model to both HCC and non-HCC patients, using the hard-coded interactions
fit_coxph_HCC_nonHCC_6months2 = coxph(
  Surv(fu_days_90days, removed_status_90days) ~ 
        nonHCC_MELD + HCC + HCC_preds6months, 
  data = train_df, x = TRUE)

df_sanity = data.frame(
  HCC_proposed = t(summary(survfit(
    fit_coxph_HCC_nonHCC_6months2, 
    newdata = test_df %>% filter(HCC == TRUE)), times = 90)$surv), 
  nonHCC_MELD = t(summary(survfit(
    fit_coxph_HCC_nonHCC_6months2, 
    newdata = test_df %>% filter(HCC == TRUE) %>% 
                          mutate(HCC = 0, 
                                 nonHCC_MELD = Proposed_6months, 
                                 HCC_preds6months = 0)), times = 90)$surv)
)
summary(df_sanity$HCC_proposed - df_sanity$nonHCC_MELD)

df_sanity %>% 
  ggplot(aes(x = HCC_proposed, y = nonHCC_MELD)) + 
  geom_point() + 
  geom_abline(intercept = 0, slope = 1, color = "grey") + 
  xlab("Using proposed score for HCC patients") + 
  ylab("Using MELD score for non-HCC patients") + 
  ggtitle("Predicted 90-day survival")
```

We plot the 90-day survival probability of non-HCC patients with a given MELD 3.0 score against the 90-day survival probability of HCC patients with the same-valued proposed score. 

```{r}
data.frame(
  test_df, 
  surv = t(summary(survfit(fit_coxph_HCC_nonHCC_6months2, 
                                 newdata = test_df), times = 90)$surv)) %>% 
  mutate(
    # Use proposed score for HCC, MELD 3.0 for non-HCC
    composite_score = case_when(
      HCC == TRUE ~ Proposed_6months, 
      HCC == FALSE ~ MELD3, 
      TRUE ~ NA), 
    # Round score
    composite_score_rounded = round(composite_score)) %>% 
  # Keep only scores between 6 and 40
  filter(composite_score_rounded >= 6 & composite_score_rounded <= 40) %>% 
  # Keep observations that are closest to the rounded score
  group_by(composite_score_rounded, HCC) %>% 
  arrange(abs(composite_score_rounded - composite_score)) %>% 
  summarize(surv = first(surv)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = HCC, values_from = surv) %>% 
  ggplot(aes(x = `0`, y = `1`, color = composite_score_rounded)) + 
  geom_point() + 
  geom_abline(intercept = 0, slope = 1, color = "grey") + 
  viridis::scale_color_viridis("MELD 3.0 or\nmulti-HCC", option = "D")+
  scale_x_log10() + scale_y_log10() + 
  xlim(0, 1) + ylim(0, 1) + 
  xlab("MELD 3.0 (non-HCC patients)") + ylab("Multi-HCC (HCC patients)")
```
